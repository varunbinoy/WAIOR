"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protocol buffer used to parametrize an iterated local search (ILS) approach.
ILS is an iterative metaheuristic in which every iteration consists in
performing a perturbation followed by an improvement step on a reference
solution to generate a neighbor solution.
The neighbor solution is accepted as the new reference solution according
to an acceptance criterion.
The best found solution is eventually returned.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ortools.constraint_solver.routing_enums_pb2
import ortools.constraint_solver.routing_heuristic_parameters_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class SpatiallyCloseRoutesRuinStrategy(google.protobuf.message.Message):
    """Ruin strategy that removes a number of spatially close routes."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUM_RUINED_ROUTES_FIELD_NUMBER: builtins.int
    num_ruined_routes: builtins.int
    """Number of spatially close routes ruined at each ruin application."""
    def __init__(
        self,
        *,
        num_ruined_routes: builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_num_ruined_routes", b"_num_ruined_routes", "num_ruined_routes", b"num_ruined_routes"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_num_ruined_routes", b"_num_ruined_routes", "num_ruined_routes", b"num_ruined_routes"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__num_ruined_routes: typing_extensions.TypeAlias = typing.Literal["num_ruined_routes"]
    _WhichOneofArgType__num_ruined_routes: typing_extensions.TypeAlias = typing.Literal["_num_ruined_routes", b"_num_ruined_routes"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType__num_ruined_routes) -> _WhichOneofReturnType__num_ruined_routes | None: ...

Global___SpatiallyCloseRoutesRuinStrategy: typing_extensions.TypeAlias = SpatiallyCloseRoutesRuinStrategy

@typing.final
class RandomWalkRuinStrategy(google.protobuf.message.Message):
    """Ruin strategy that removes a number of nodes by performing a random walk
    on the underlying routing solution. More precisely, starting from a randomly
    selected seed visit, the walk is extended by either moving within the
    same route or by jumping to a visit served by a different neighboring
    route. Every active visit encountered along this random walk is made
    unperformed.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUM_REMOVED_VISITS_FIELD_NUMBER: builtins.int
    num_removed_visits: builtins.int
    """Number of visits removed during a ruin application defined on visits.
    Note that pickup and delivery pairs are considered as a single entity,
    i.e., the removal of a pickup (respectively delivery) causes the removal of
    the associated delivery (respectively pickup) and it counts as a single
    removal.
    """
    def __init__(
        self,
        *,
        num_removed_visits: builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_num_removed_visits", b"_num_removed_visits", "num_removed_visits", b"num_removed_visits"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_num_removed_visits", b"_num_removed_visits", "num_removed_visits", b"num_removed_visits"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__num_removed_visits: typing_extensions.TypeAlias = typing.Literal["num_removed_visits"]
    _WhichOneofArgType__num_removed_visits: typing_extensions.TypeAlias = typing.Literal["_num_removed_visits", b"_num_removed_visits"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType__num_removed_visits) -> _WhichOneofReturnType__num_removed_visits | None: ...

Global___RandomWalkRuinStrategy: typing_extensions.TypeAlias = RandomWalkRuinStrategy

@typing.final
class SISRRuinStrategy(google.protobuf.message.Message):
    """Ruin strategy based on the "Slack Induction by String Removals for Vehicle
    Routing Problems" by Jan Christiaens and Greet Vanden Berghe, Transportation
    Science 2020.

    Note that, in this implementation, the notion of "string" is replaced by
    "sequence".

    The main idea of this ruin is to remove a number of geographically close
    sequences of nodes. In particular, at every ruin application, a maximum
    number max_ruined_routes of routes are disrupted. The value for
    max_ruined_routes is defined as
          (4 * avg_num_removed_visits) / (1 + max_sequence_size) + 1
    with
    - avg_num_removed_visits: user-defined parameter ruling the average number of
      visits that are removed in face of several ruin applications (see also the
      proto message below)
    - max_sequence_size is defined as
           min{max_removed_sequence_size, average_route_size}
      with
      - max_removed_sequence_size: user-defined parameter that specifies
        the maximum number of visits removed from a single route (see also the
        proto message below)
      - average_route_size: the average size of a non-empty route in the current
        solution

    The actual number of ruined routes is then obtained as
                     floor(U(1, max_ruined_routes + 1))
    where U is a continuous uniform distribution of real values in the given
    interval.

    The routes affected by the ruin procedure are selected as follows.
    First, a non start/end seed node is randomly selected. The route serving this
    node is the first ruined route. Then, until the required number of routes has
    been ruined, neighbor nodes of the initial seed node are scanned and the
    associated not yet ruined routes are disrupted. Nodes defining the selected
    routes are designated as seed nodes for the "sequence" and "split sequence"
    removal procedures described below.

    For every selected route, a maximum number route_max_sequence_size of nodes
    are removed. In particular, route_max_sequence_size is defined as
                   min{route_size, max_sequence_size}
    with route_size being the size of the current route.

    Then, the actual number of removed nodes num_removed_nodes is defined as
                 floor(U(1, route_max_sequence_size + 1))
    where U is a continuous uniform distribution of real values in the given
    interval.

    As mentioned above, the selected num_removed_nodes number of nodes is removed
    either via the "sequence" removal or "split sequence" removal procedures. The
    two removal procedures are executed with equal probabilities.

    The "sequence" removal procedure removes a randomly selected sequence of size
    num_removed_nodes that includes the seed node.

    The "split sequence" removal procedure also removes a randomly selected
    sequence of size num_removed_nodes that includes the seed node, but it can
    possibly preserve a subsequence of contiguous nodes.
    In particular, the procedure first selects a sequence of size
    num_removed_nodes + num_bypassed, then num_bypassed contiguous nodes in the
    selected sequence are preserved while the others removed.

    The definition of num_bypassed is as follows. First num_bypassed = 1. The
    current value of num_bypassed is maintaned if
             U(0, 1) < bypass_factor * U(0, 1)
    or the maximum value for num_bypassed, equal to
              route_size - num_removed_nodes
    is reached. The value is incremented of a unit otherwise,
    and the process is repeated. The value assigned to bypass_factor affects the
    number of preserved visits (see also the proto message below).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAX_REMOVED_SEQUENCE_SIZE_FIELD_NUMBER: builtins.int
    AVG_NUM_REMOVED_VISITS_FIELD_NUMBER: builtins.int
    BYPASS_FACTOR_FIELD_NUMBER: builtins.int
    max_removed_sequence_size: builtins.int
    """Maximum number of removed visits per sequence. The parameter name in the
    paper is L^{max} and the suggested value is 10.
    """
    avg_num_removed_visits: builtins.int
    """Number of visits that are removed on average. The parameter name in the
    paper is \\bar{c} and the suggested value is 10.
    """
    bypass_factor: builtins.float
    """Value in [0, 1] ruling the number of preserved nodes in the split
    sequence removal. The parameter name in the paper is \\alpha and the
    suggested value is 0.01.
    """
    def __init__(
        self,
        *,
        max_removed_sequence_size: builtins.int | None = ...,
        avg_num_removed_visits: builtins.int | None = ...,
        bypass_factor: builtins.float | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_avg_num_removed_visits", b"_avg_num_removed_visits", "_bypass_factor", b"_bypass_factor", "_max_removed_sequence_size", b"_max_removed_sequence_size", "avg_num_removed_visits", b"avg_num_removed_visits", "bypass_factor", b"bypass_factor", "max_removed_sequence_size", b"max_removed_sequence_size"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_avg_num_removed_visits", b"_avg_num_removed_visits", "_bypass_factor", b"_bypass_factor", "_max_removed_sequence_size", b"_max_removed_sequence_size", "avg_num_removed_visits", b"avg_num_removed_visits", "bypass_factor", b"bypass_factor", "max_removed_sequence_size", b"max_removed_sequence_size"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__avg_num_removed_visits: typing_extensions.TypeAlias = typing.Literal["avg_num_removed_visits"]
    _WhichOneofArgType__avg_num_removed_visits: typing_extensions.TypeAlias = typing.Literal["_avg_num_removed_visits", b"_avg_num_removed_visits"]
    _WhichOneofReturnType__bypass_factor: typing_extensions.TypeAlias = typing.Literal["bypass_factor"]
    _WhichOneofArgType__bypass_factor: typing_extensions.TypeAlias = typing.Literal["_bypass_factor", b"_bypass_factor"]
    _WhichOneofReturnType__max_removed_sequence_size: typing_extensions.TypeAlias = typing.Literal["max_removed_sequence_size"]
    _WhichOneofArgType__max_removed_sequence_size: typing_extensions.TypeAlias = typing.Literal["_max_removed_sequence_size", b"_max_removed_sequence_size"]
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__avg_num_removed_visits) -> _WhichOneofReturnType__avg_num_removed_visits | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__bypass_factor) -> _WhichOneofReturnType__bypass_factor | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__max_removed_sequence_size) -> _WhichOneofReturnType__max_removed_sequence_size | None: ...

Global___SISRRuinStrategy: typing_extensions.TypeAlias = SISRRuinStrategy

@typing.final
class RuinStrategy(google.protobuf.message.Message):
    """Ruin strategies, used in perturbation based on ruin and recreate approaches."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SPATIALLY_CLOSE_ROUTES_FIELD_NUMBER: builtins.int
    RANDOM_WALK_FIELD_NUMBER: builtins.int
    SISR_FIELD_NUMBER: builtins.int
    @property
    def spatially_close_routes(self) -> Global___SpatiallyCloseRoutesRuinStrategy: ...
    @property
    def random_walk(self) -> Global___RandomWalkRuinStrategy: ...
    @property
    def sisr(self) -> Global___SISRRuinStrategy: ...
    def __init__(
        self,
        *,
        spatially_close_routes: Global___SpatiallyCloseRoutesRuinStrategy | None = ...,
        random_walk: Global___RandomWalkRuinStrategy | None = ...,
        sisr: Global___SISRRuinStrategy | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["random_walk", b"random_walk", "sisr", b"sisr", "spatially_close_routes", b"spatially_close_routes", "strategy", b"strategy"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["random_walk", b"random_walk", "sisr", b"sisr", "spatially_close_routes", b"spatially_close_routes", "strategy", b"strategy"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_strategy: typing_extensions.TypeAlias = typing.Literal["spatially_close_routes", "random_walk", "sisr"]
    _WhichOneofArgType_strategy: typing_extensions.TypeAlias = typing.Literal["strategy", b"strategy"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType_strategy) -> _WhichOneofReturnType_strategy | None: ...

Global___RuinStrategy: typing_extensions.TypeAlias = RuinStrategy

@typing.final
class RecreateParameters(google.protobuf.message.Message):
    """Parameters to customize a recreate strategy."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOCAL_CHEAPEST_INSERTION_FIELD_NUMBER: builtins.int
    SAVINGS_FIELD_NUMBER: builtins.int
    GLOBAL_CHEAPEST_INSERTION_FIELD_NUMBER: builtins.int
    @property
    def local_cheapest_insertion(self) -> ortools.constraint_solver.routing_heuristic_parameters_pb2.LocalCheapestInsertionParameters: ...
    @property
    def savings(self) -> ortools.constraint_solver.routing_heuristic_parameters_pb2.SavingsParameters: ...
    @property
    def global_cheapest_insertion(self) -> ortools.constraint_solver.routing_heuristic_parameters_pb2.GlobalCheapestInsertionParameters: ...
    def __init__(
        self,
        *,
        local_cheapest_insertion: ortools.constraint_solver.routing_heuristic_parameters_pb2.LocalCheapestInsertionParameters | None = ...,
        savings: ortools.constraint_solver.routing_heuristic_parameters_pb2.SavingsParameters | None = ...,
        global_cheapest_insertion: ortools.constraint_solver.routing_heuristic_parameters_pb2.GlobalCheapestInsertionParameters | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["global_cheapest_insertion", b"global_cheapest_insertion", "local_cheapest_insertion", b"local_cheapest_insertion", "parameters", b"parameters", "savings", b"savings"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["global_cheapest_insertion", b"global_cheapest_insertion", "local_cheapest_insertion", b"local_cheapest_insertion", "parameters", b"parameters", "savings", b"savings"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_parameters: typing_extensions.TypeAlias = typing.Literal["local_cheapest_insertion", "savings", "global_cheapest_insertion"]
    _WhichOneofArgType_parameters: typing_extensions.TypeAlias = typing.Literal["parameters", b"parameters"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType_parameters) -> _WhichOneofReturnType_parameters | None: ...

Global___RecreateParameters: typing_extensions.TypeAlias = RecreateParameters

@typing.final
class RecreateStrategy(google.protobuf.message.Message):
    """Strategy defining how a solution is recreated."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HEURISTIC_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    heuristic: ortools.constraint_solver.routing_enums_pb2.FirstSolutionStrategy.Value.ValueType
    @property
    def parameters(self) -> Global___RecreateParameters:
        """The selected parameters should match the chosen recreate heuristic.
        If not set, the default parameters from the RoutingModel are used.
        """

    def __init__(
        self,
        *,
        heuristic: ortools.constraint_solver.routing_enums_pb2.FirstSolutionStrategy.Value.ValueType | None = ...,
        parameters: Global___RecreateParameters | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_heuristic", b"_heuristic", "_parameters", b"_parameters", "heuristic", b"heuristic", "parameters", b"parameters"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_heuristic", b"_heuristic", "_parameters", b"_parameters", "heuristic", b"heuristic", "parameters", b"parameters"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__heuristic: typing_extensions.TypeAlias = typing.Literal["heuristic"]
    _WhichOneofArgType__heuristic: typing_extensions.TypeAlias = typing.Literal["_heuristic", b"_heuristic"]
    _WhichOneofReturnType__parameters: typing_extensions.TypeAlias = typing.Literal["parameters"]
    _WhichOneofArgType__parameters: typing_extensions.TypeAlias = typing.Literal["_parameters", b"_parameters"]
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__heuristic) -> _WhichOneofReturnType__heuristic | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__parameters) -> _WhichOneofReturnType__parameters | None: ...

Global___RecreateStrategy: typing_extensions.TypeAlias = RecreateStrategy

@typing.final
class RuinCompositionStrategy(google.protobuf.message.Message):
    """The ruin composition strategies specifies how ruin are selected at every ILS
    iteration.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Value:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RuinCompositionStrategy._Value.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSET: RuinCompositionStrategy._Value.ValueType  # 0
        """Unspecified value."""
        RUN_ALL_SEQUENTIALLY: RuinCompositionStrategy._Value.ValueType  # 1
        """Execute all ruin strategies sequentially in the same order provided in
        input.
        """
        RUN_ALL_RANDOMLY: RuinCompositionStrategy._Value.ValueType  # 2
        """Execute all ruin strategies in a random order."""
        RUN_ONE_RANDOMLY: RuinCompositionStrategy._Value.ValueType  # 3
        """Execute a randomly selected ruin."""

    class Value(_Value, metaclass=_ValueEnumTypeWrapper): ...
    UNSET: RuinCompositionStrategy.Value.ValueType  # 0
    """Unspecified value."""
    RUN_ALL_SEQUENTIALLY: RuinCompositionStrategy.Value.ValueType  # 1
    """Execute all ruin strategies sequentially in the same order provided in
    input.
    """
    RUN_ALL_RANDOMLY: RuinCompositionStrategy.Value.ValueType  # 2
    """Execute all ruin strategies in a random order."""
    RUN_ONE_RANDOMLY: RuinCompositionStrategy.Value.ValueType  # 3
    """Execute a randomly selected ruin."""

    def __init__(
        self,
    ) -> None: ...

Global___RuinCompositionStrategy: typing_extensions.TypeAlias = RuinCompositionStrategy

@typing.final
class RuinRecreateParameters(google.protobuf.message.Message):
    """Parameters to configure a perturbation based on a ruin and recreate approach."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RUIN_STRATEGIES_FIELD_NUMBER: builtins.int
    RUIN_COMPOSITION_STRATEGY_FIELD_NUMBER: builtins.int
    RECREATE_STRATEGY_FIELD_NUMBER: builtins.int
    ROUTE_SELECTION_NEIGHBORS_RATIO_FIELD_NUMBER: builtins.int
    ROUTE_SELECTION_MIN_NEIGHBORS_FIELD_NUMBER: builtins.int
    ROUTE_SELECTION_MAX_NEIGHBORS_FIELD_NUMBER: builtins.int
    ruin_composition_strategy: Global___RuinCompositionStrategy.Value.ValueType
    """The composition strategy to use when combining the given 'ruin_strategies'.
    Has no effect when ruin_strategies is composed of a single strategy.
    """
    route_selection_neighbors_ratio: builtins.float
    """Ratio in [0, 1] of non start/end nodes to consider as neighbors for the
    identification of routes spatially close to a non start/end seed node.

    In particular, given a non start/end seed node s served by route r, we say
    that a route r' is spatially close to the seed node s if there is at
    least one non start/end node s' among the neighbors of s, such that s' is
    served by r'.

    The neighbors_ratio is coupled with the corresponding min_neighbors and
    max_neighbors values, defining the minimum and maximum number of neighbor
    nodes considered for a given seed node:
    num_neighbors = min(max_neighbors,
             max(min_neighbors, neighbors_ratio * NUM_NON_START_END_NODES))

    Neighbors ratio, and minimum and maximum number of non start/end neighbor
    nodes for the identification of spatially close routes.
    """
    route_selection_min_neighbors: builtins.int
    route_selection_max_neighbors: builtins.int
    @property
    def ruin_strategies(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___RuinStrategy]:
        """List of ruin strategies determining how a reference solution is ruined."""

    @property
    def recreate_strategy(self) -> Global___RecreateStrategy:
        """Strategy defining how a reference solution is recreated."""

    def __init__(
        self,
        *,
        ruin_strategies: collections.abc.Iterable[Global___RuinStrategy] | None = ...,
        ruin_composition_strategy: Global___RuinCompositionStrategy.Value.ValueType = ...,
        recreate_strategy: Global___RecreateStrategy | None = ...,
        route_selection_neighbors_ratio: builtins.float | None = ...,
        route_selection_min_neighbors: builtins.int | None = ...,
        route_selection_max_neighbors: builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_route_selection_max_neighbors", b"_route_selection_max_neighbors", "_route_selection_min_neighbors", b"_route_selection_min_neighbors", "_route_selection_neighbors_ratio", b"_route_selection_neighbors_ratio", "recreate_strategy", b"recreate_strategy", "route_selection_max_neighbors", b"route_selection_max_neighbors", "route_selection_min_neighbors", b"route_selection_min_neighbors", "route_selection_neighbors_ratio", b"route_selection_neighbors_ratio"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_route_selection_max_neighbors", b"_route_selection_max_neighbors", "_route_selection_min_neighbors", b"_route_selection_min_neighbors", "_route_selection_neighbors_ratio", b"_route_selection_neighbors_ratio", "recreate_strategy", b"recreate_strategy", "route_selection_max_neighbors", b"route_selection_max_neighbors", "route_selection_min_neighbors", b"route_selection_min_neighbors", "route_selection_neighbors_ratio", b"route_selection_neighbors_ratio", "ruin_composition_strategy", b"ruin_composition_strategy", "ruin_strategies", b"ruin_strategies"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__route_selection_max_neighbors: typing_extensions.TypeAlias = typing.Literal["route_selection_max_neighbors"]
    _WhichOneofArgType__route_selection_max_neighbors: typing_extensions.TypeAlias = typing.Literal["_route_selection_max_neighbors", b"_route_selection_max_neighbors"]
    _WhichOneofReturnType__route_selection_min_neighbors: typing_extensions.TypeAlias = typing.Literal["route_selection_min_neighbors"]
    _WhichOneofArgType__route_selection_min_neighbors: typing_extensions.TypeAlias = typing.Literal["_route_selection_min_neighbors", b"_route_selection_min_neighbors"]
    _WhichOneofReturnType__route_selection_neighbors_ratio: typing_extensions.TypeAlias = typing.Literal["route_selection_neighbors_ratio"]
    _WhichOneofArgType__route_selection_neighbors_ratio: typing_extensions.TypeAlias = typing.Literal["_route_selection_neighbors_ratio", b"_route_selection_neighbors_ratio"]
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__route_selection_max_neighbors) -> _WhichOneofReturnType__route_selection_max_neighbors | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__route_selection_min_neighbors) -> _WhichOneofReturnType__route_selection_min_neighbors | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__route_selection_neighbors_ratio) -> _WhichOneofReturnType__route_selection_neighbors_ratio | None: ...

Global___RuinRecreateParameters: typing_extensions.TypeAlias = RuinRecreateParameters

@typing.final
class PerturbationStrategy(google.protobuf.message.Message):
    """Defines how a reference solution is perturbed."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Value:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PerturbationStrategy._Value.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSET: PerturbationStrategy._Value.ValueType  # 0
        """Unspecified value."""
        RUIN_AND_RECREATE: PerturbationStrategy._Value.ValueType  # 1
        """Performs a perturbation in a ruin and recreate fashion."""

    class Value(_Value, metaclass=_ValueEnumTypeWrapper): ...
    UNSET: PerturbationStrategy.Value.ValueType  # 0
    """Unspecified value."""
    RUIN_AND_RECREATE: PerturbationStrategy.Value.ValueType  # 1
    """Performs a perturbation in a ruin and recreate fashion."""

    def __init__(
        self,
    ) -> None: ...

Global___PerturbationStrategy: typing_extensions.TypeAlias = PerturbationStrategy

@typing.final
class CoolingScheduleStrategy(google.protobuf.message.Message):
    """The cooling schedule strategy defines how to compute the current simulated
    annealing temperature t given
    - the initial temperature t0
    - the final temperature t1
    - the current search progress 0 <= p <= 1

    The value of t0 and t1 is defined by the initial_temperature and
    final_temperature in SimulatedAnnealingParameters, respectively.

    The search progress p is derived, at any given time, by the search limits.
    In particular, p measures how far we are in the search process w.r.t. to the
    number of explored solutions and the time limit.

    The temperature t, computed according to one of the strategies defined below,
    together with the selected AcceptanceStrategy, is used to guide the search
    trajectory. In particular, given a neighbor solution S', generated by the
    the application of the perturbation and improvement step to a reference
    solution S, we have that S will be replaced by S' iff
                     cost(S') + t * log(U(0, 1)) < cost(S)
    where U(0, 1) is a random number sampled from a uniform distribution of real
    numbers in [0, 1].
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Value:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CoolingScheduleStrategy._Value.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSET: CoolingScheduleStrategy._Value.ValueType  # 0
        """Unspecified value."""
        EXPONENTIAL: CoolingScheduleStrategy._Value.ValueType  # 1
        """Exponentially decreases the temperature as the search progresses.
        More precisely, t = t0 * (t1/t0)^p.
        """
        LINEAR: CoolingScheduleStrategy._Value.ValueType  # 2
        """Linearly decreases the temperature as the search progresses.
        More precisely, t = t0 - p * (t0 - t1).
        """

    class Value(_Value, metaclass=_ValueEnumTypeWrapper): ...
    UNSET: CoolingScheduleStrategy.Value.ValueType  # 0
    """Unspecified value."""
    EXPONENTIAL: CoolingScheduleStrategy.Value.ValueType  # 1
    """Exponentially decreases the temperature as the search progresses.
    More precisely, t = t0 * (t1/t0)^p.
    """
    LINEAR: CoolingScheduleStrategy.Value.ValueType  # 2
    """Linearly decreases the temperature as the search progresses.
    More precisely, t = t0 - p * (t0 - t1).
    """

    def __init__(
        self,
    ) -> None: ...

Global___CoolingScheduleStrategy: typing_extensions.TypeAlias = CoolingScheduleStrategy

@typing.final
class GreedyDescentAcceptanceStrategy(google.protobuf.message.Message):
    """Acceptance strategy in which only improving solutions are accepted."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___GreedyDescentAcceptanceStrategy: typing_extensions.TypeAlias = GreedyDescentAcceptanceStrategy

@typing.final
class SimulatedAnnealingAcceptanceStrategy(google.protobuf.message.Message):
    """Acceptance strategy in which solutions are accepted with a probability that
    depends on its quality and on the current state of the search.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COOLING_SCHEDULE_STRATEGY_FIELD_NUMBER: builtins.int
    INITIAL_TEMPERATURE_FIELD_NUMBER: builtins.int
    FINAL_TEMPERATURE_FIELD_NUMBER: builtins.int
    AUTOMATIC_TEMPERATURES_FIELD_NUMBER: builtins.int
    cooling_schedule_strategy: Global___CoolingScheduleStrategy.Value.ValueType
    """Determines the speed at which the temperature changes from initial to
    final.
    """
    initial_temperature: builtins.float
    """The initial temperature. See CoolingScheduleStrategy for its usage."""
    final_temperature: builtins.float
    """The final temperature. See CoolingScheduleStrategy for its usage."""
    automatic_temperatures: builtins.bool
    """Automatically define the value for the temperatures as follows.
    First, a  reference temperature t is defined as
              w1 * c1 + w2 * c2 + ... + wK * cK
    where 0 < wJ <= 1 is the fraction of vehicles of cost class J and cJ is the
    average arc cost for the cost class J.
    The value of cJ is identified by randomly sampling N arc costs for the cost
    class J, where N is equal to the number of instance nodes.
    The initial and final temperatures are then defined as
    - initial_temperature: 0.1 * t
    - final_temperature: 0.001 * t
    """
    def __init__(
        self,
        *,
        cooling_schedule_strategy: Global___CoolingScheduleStrategy.Value.ValueType = ...,
        initial_temperature: builtins.float | None = ...,
        final_temperature: builtins.float | None = ...,
        automatic_temperatures: builtins.bool | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_automatic_temperatures", b"_automatic_temperatures", "_final_temperature", b"_final_temperature", "_initial_temperature", b"_initial_temperature", "automatic_temperatures", b"automatic_temperatures", "final_temperature", b"final_temperature", "initial_temperature", b"initial_temperature"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_automatic_temperatures", b"_automatic_temperatures", "_final_temperature", b"_final_temperature", "_initial_temperature", b"_initial_temperature", "automatic_temperatures", b"automatic_temperatures", "cooling_schedule_strategy", b"cooling_schedule_strategy", "final_temperature", b"final_temperature", "initial_temperature", b"initial_temperature"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__automatic_temperatures: typing_extensions.TypeAlias = typing.Literal["automatic_temperatures"]
    _WhichOneofArgType__automatic_temperatures: typing_extensions.TypeAlias = typing.Literal["_automatic_temperatures", b"_automatic_temperatures"]
    _WhichOneofReturnType__final_temperature: typing_extensions.TypeAlias = typing.Literal["final_temperature"]
    _WhichOneofArgType__final_temperature: typing_extensions.TypeAlias = typing.Literal["_final_temperature", b"_final_temperature"]
    _WhichOneofReturnType__initial_temperature: typing_extensions.TypeAlias = typing.Literal["initial_temperature"]
    _WhichOneofArgType__initial_temperature: typing_extensions.TypeAlias = typing.Literal["_initial_temperature", b"_initial_temperature"]
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__automatic_temperatures) -> _WhichOneofReturnType__automatic_temperatures | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__final_temperature) -> _WhichOneofReturnType__final_temperature | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__initial_temperature) -> _WhichOneofReturnType__initial_temperature | None: ...

Global___SimulatedAnnealingAcceptanceStrategy: typing_extensions.TypeAlias = SimulatedAnnealingAcceptanceStrategy

@typing.final
class AllNodesPerformedAcceptanceStrategy(google.protobuf.message.Message):
    """Acceptance strategy in which a solution is accepted only if all nodes
    are performed. Disjunctions are respected when several nodes can be
    performed.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___AllNodesPerformedAcceptanceStrategy: typing_extensions.TypeAlias = AllNodesPerformedAcceptanceStrategy

@typing.final
class MoreNodesPerformedAcceptanceStrategy(google.protobuf.message.Message):
    """Acceptance strategy in which a solution is accepted only if it performs at
    least one more node than the reference solution.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___MoreNodesPerformedAcceptanceStrategy: typing_extensions.TypeAlias = MoreNodesPerformedAcceptanceStrategy

@typing.final
class AbsencesBasedAcceptanceStrategy(google.protobuf.message.Message):
    """Acceptance strategy in which a solution is accepted only if it has less
    absences than the reference solution (see Slack Induction by String Removals
    for Vehicle Routing Problems" Christiaens and Vanden Berghe, Transportation
    Science 2020).

    In particular, for each node n, the number of solutions where n was not
    performed by any route is tracked by a counter absences[n]. A candidate is
    accepted if
             sum(absences[n]) < sum(absences[m])
    with
             n in unperformed(candidate)
             m in unperformed(reference)

    The counter absences is increased after every ILS iteration for the
    unperformed nodes in the reference solution. In addition, when
    remove_route_with_lowest_absences is true and a new best found solution is
    found, the route with the lowest sum of absences is removed from the
    reference solution.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REMOVE_ROUTE_WITH_LOWEST_ABSENCES_FIELD_NUMBER: builtins.int
    remove_route_with_lowest_absences: builtins.bool
    """If true, when a new best solution is found, the route with the lowest sum
    of absences is removed from the reference solution.
    """
    def __init__(
        self,
        *,
        remove_route_with_lowest_absences: builtins.bool | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_remove_route_with_lowest_absences", b"_remove_route_with_lowest_absences", "remove_route_with_lowest_absences", b"remove_route_with_lowest_absences"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_remove_route_with_lowest_absences", b"_remove_route_with_lowest_absences", "remove_route_with_lowest_absences", b"remove_route_with_lowest_absences"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__remove_route_with_lowest_absences: typing_extensions.TypeAlias = typing.Literal["remove_route_with_lowest_absences"]
    _WhichOneofArgType__remove_route_with_lowest_absences: typing_extensions.TypeAlias = typing.Literal["_remove_route_with_lowest_absences", b"_remove_route_with_lowest_absences"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType__remove_route_with_lowest_absences) -> _WhichOneofReturnType__remove_route_with_lowest_absences | None: ...

Global___AbsencesBasedAcceptanceStrategy: typing_extensions.TypeAlias = AbsencesBasedAcceptanceStrategy

@typing.final
class AcceptanceStrategy(google.protobuf.message.Message):
    """Determines when a candidate solution replaces another one."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GREEDY_DESCENT_FIELD_NUMBER: builtins.int
    SIMULATED_ANNEALING_FIELD_NUMBER: builtins.int
    ALL_NODES_PERFORMED_FIELD_NUMBER: builtins.int
    MORE_NODES_PERFORMED_FIELD_NUMBER: builtins.int
    ABSENCES_BASED_FIELD_NUMBER: builtins.int
    @property
    def greedy_descent(self) -> Global___GreedyDescentAcceptanceStrategy: ...
    @property
    def simulated_annealing(self) -> Global___SimulatedAnnealingAcceptanceStrategy: ...
    @property
    def all_nodes_performed(self) -> Global___AllNodesPerformedAcceptanceStrategy: ...
    @property
    def more_nodes_performed(self) -> Global___MoreNodesPerformedAcceptanceStrategy: ...
    @property
    def absences_based(self) -> Global___AbsencesBasedAcceptanceStrategy: ...
    def __init__(
        self,
        *,
        greedy_descent: Global___GreedyDescentAcceptanceStrategy | None = ...,
        simulated_annealing: Global___SimulatedAnnealingAcceptanceStrategy | None = ...,
        all_nodes_performed: Global___AllNodesPerformedAcceptanceStrategy | None = ...,
        more_nodes_performed: Global___MoreNodesPerformedAcceptanceStrategy | None = ...,
        absences_based: Global___AbsencesBasedAcceptanceStrategy | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["absences_based", b"absences_based", "all_nodes_performed", b"all_nodes_performed", "greedy_descent", b"greedy_descent", "more_nodes_performed", b"more_nodes_performed", "simulated_annealing", b"simulated_annealing", "strategy", b"strategy"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["absences_based", b"absences_based", "all_nodes_performed", b"all_nodes_performed", "greedy_descent", b"greedy_descent", "more_nodes_performed", b"more_nodes_performed", "simulated_annealing", b"simulated_annealing", "strategy", b"strategy"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_strategy: typing_extensions.TypeAlias = typing.Literal["greedy_descent", "simulated_annealing", "all_nodes_performed", "more_nodes_performed", "absences_based"]
    _WhichOneofArgType_strategy: typing_extensions.TypeAlias = typing.Literal["strategy", b"strategy"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType_strategy) -> _WhichOneofReturnType_strategy | None: ...

Global___AcceptanceStrategy: typing_extensions.TypeAlias = AcceptanceStrategy

@typing.final
class IteratedLocalSearchParameters(google.protobuf.message.Message):
    """Specifies the behavior of a search based on ILS."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PERTURBATION_STRATEGY_FIELD_NUMBER: builtins.int
    RUIN_RECREATE_PARAMETERS_FIELD_NUMBER: builtins.int
    IMPROVE_PERTURBED_SOLUTION_FIELD_NUMBER: builtins.int
    REFERENCE_SOLUTION_ACCEPTANCE_STRATEGY_FIELD_NUMBER: builtins.int
    BEST_SOLUTION_ACCEPTANCE_STRATEGY_FIELD_NUMBER: builtins.int
    perturbation_strategy: Global___PerturbationStrategy.Value.ValueType
    """Determines how a reference solution S is perturbed to obtain a neighbor
    solution S'.
    """
    improve_perturbed_solution: builtins.bool
    """Determines whether solution S', obtained from the perturbation, should be
    optimized with a local search application.
    """
    @property
    def ruin_recreate_parameters(self) -> Global___RuinRecreateParameters:
        """Parameters to customize a ruin and recreate perturbation."""

    @property
    def reference_solution_acceptance_strategy(self) -> Global___AcceptanceStrategy:
        """Determines when the neighbor solution S', possibly improved if
        `improve_perturbed_solution` is true, replaces the reference solution S.
        """

    @property
    def best_solution_acceptance_strategy(self) -> Global___AcceptanceStrategy:
        """Determines when the neighbor solution S' replaces the best solution found
        so far.
        """

    def __init__(
        self,
        *,
        perturbation_strategy: Global___PerturbationStrategy.Value.ValueType = ...,
        ruin_recreate_parameters: Global___RuinRecreateParameters | None = ...,
        improve_perturbed_solution: builtins.bool | None = ...,
        reference_solution_acceptance_strategy: Global___AcceptanceStrategy | None = ...,
        best_solution_acceptance_strategy: Global___AcceptanceStrategy | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_improve_perturbed_solution", b"_improve_perturbed_solution", "best_solution_acceptance_strategy", b"best_solution_acceptance_strategy", "improve_perturbed_solution", b"improve_perturbed_solution", "reference_solution_acceptance_strategy", b"reference_solution_acceptance_strategy", "ruin_recreate_parameters", b"ruin_recreate_parameters"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_improve_perturbed_solution", b"_improve_perturbed_solution", "best_solution_acceptance_strategy", b"best_solution_acceptance_strategy", "improve_perturbed_solution", b"improve_perturbed_solution", "perturbation_strategy", b"perturbation_strategy", "reference_solution_acceptance_strategy", b"reference_solution_acceptance_strategy", "ruin_recreate_parameters", b"ruin_recreate_parameters"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__improve_perturbed_solution: typing_extensions.TypeAlias = typing.Literal["improve_perturbed_solution"]
    _WhichOneofArgType__improve_perturbed_solution: typing_extensions.TypeAlias = typing.Literal["_improve_perturbed_solution", b"_improve_perturbed_solution"]
    def WhichOneof(self, oneof_group: _WhichOneofArgType__improve_perturbed_solution) -> _WhichOneofReturnType__improve_perturbed_solution | None: ...

Global___IteratedLocalSearchParameters: typing_extensions.TypeAlias = IteratedLocalSearchParameters
