import RoutesConstraintProto
import ortools.util.python.sorted_interval_list
import typing
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar, overload

FEASIBLE: CpSolverStatus
INFEASIBLE: CpSolverStatus
MODEL_INVALID: CpSolverStatus
OPTIMAL: CpSolverStatus
UNKNOWN: CpSolverStatus
at_most_one: BoolArgumentConstraint
bool_and: BoolArgumentConstraint
bool_or: BoolArgumentConstraint
bool_xor: BoolArgumentConstraint
div: LinearArgumentConstraint
exactly_one: BoolArgumentConstraint
max: LinearArgumentConstraint
min: LinearArgumentConstraint
mod: LinearArgumentConstraint
prod: LinearArgumentConstraint

class AllDifferentConstraintProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: AllDifferentConstraintProto) -> None: ...
    def merge_from(self, arg0: AllDifferentConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> AllDifferentConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> AllDifferentConstraintProto: ...
    @property
    def exprs(self): ...

class AutomatonConstraintProto:
    starting_state: int
    def __init__(self) -> None: ...
    def clear_starting_state(self) -> None: ...
    def copy_from(self, arg0: AutomatonConstraintProto) -> None: ...
    def merge_from(self, arg0: AutomatonConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> AutomatonConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> AutomatonConstraintProto: ...
    @property
    def exprs(self): ...
    @property
    def final_states(self): ...
    @property
    def transition_head(self): ...
    @property
    def transition_label(self): ...
    @property
    def transition_tail(self): ...
    @property
    def vars(self): ...

class BoolArgumentConstraint:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    at_most_one: ClassVar[BoolArgumentConstraint] = ...
    bool_and: ClassVar[BoolArgumentConstraint] = ...
    bool_or: ClassVar[BoolArgumentConstraint] = ...
    bool_xor: ClassVar[BoolArgumentConstraint] = ...
    exactly_one: ClassVar[BoolArgumentConstraint] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BoolArgumentProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: BoolArgumentProto) -> None: ...
    def merge_from(self, arg0: BoolArgumentProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> BoolArgumentProto: ...
    def __deepcopy__(self, arg0: dict) -> BoolArgumentProto: ...
    @property
    def literals(self): ...

class BoundedLinearExpression:
    @overload
    def __init__(self, arg0: LinearExpr, arg1: ortools.util.python.sorted_interval_list.Domain) -> None: ...
    @overload
    def __init__(self, arg0: LinearExpr, arg1: LinearExpr, arg2: ortools.util.python.sorted_interval_list.Domain) -> None: ...
    def __bool__(self) -> bool: ...
    @property
    def bounds(self) -> ortools.util.python.sorted_interval_list.Domain: ...
    @property
    def coeffs(self) -> list[int]: ...
    @property
    def offset(self) -> int: ...
    @property
    def ok(self) -> bool: ...
    @property
    def vars(self) -> list[IntVar]: ...

class CircuitConstraintProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: CircuitConstraintProto) -> None: ...
    def merge_from(self, arg0: CircuitConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> CircuitConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> CircuitConstraintProto: ...
    @property
    def heads(self): ...
    @property
    def literals(self): ...
    @property
    def tails(self): ...

class Constraint:
    name: str
    def __init__(self, arg0: CpBaseModel, arg1: int) -> None: ...
    def Index(self) -> int: ...
    def Name(self) -> str: ...
    def OnlyEnforceIf(self, *args) -> None: ...
    def Proto(self, *args, **kwargs): ...
    def WithName(self, arg0: str) -> Constraint: ...
    @overload
    def only_enforce_if(self, literal: Literal) -> Constraint: ...
    @overload
    def only_enforce_if(self, literal: bool) -> Constraint: ...
    @overload
    def only_enforce_if(self, literals: list[Literal]) -> None: ...
    @overload
    def only_enforce_if(self, *args) -> None: ...
    def with_name(self, arg0: str) -> Constraint: ...
    @property
    def index(self) -> int: ...
    @property
    def model_proto(self): ...
    @property
    def proto(self): ...

class ConstraintProto:
    all_diff: Incomplete
    at_most_one: Incomplete
    automaton: Incomplete
    bool_and: Incomplete
    bool_or: Incomplete
    bool_xor: Incomplete
    circuit: Incomplete
    cumulative: Incomplete
    dummy_constraint: Incomplete
    element: Incomplete
    exactly_one: Incomplete
    int_div: Incomplete
    int_mod: Incomplete
    int_prod: Incomplete
    interval: Incomplete
    inverse: Incomplete
    lin_max: Incomplete
    linear: Incomplete
    name: str
    no_overlap: Incomplete
    no_overlap_2d: Incomplete
    reservoir: Incomplete
    routes: Incomplete
    table: Incomplete
    def __init__(self) -> None: ...
    def clear_all_diff(self) -> None: ...
    def clear_at_most_one(self) -> None: ...
    def clear_automaton(self) -> None: ...
    def clear_bool_and(self) -> None: ...
    def clear_bool_or(self) -> None: ...
    def clear_bool_xor(self) -> None: ...
    def clear_circuit(self) -> None: ...
    def clear_cumulative(self) -> None: ...
    def clear_dummy_constraint(self) -> None: ...
    def clear_element(self) -> None: ...
    def clear_exactly_one(self) -> None: ...
    def clear_int_div(self) -> None: ...
    def clear_int_mod(self) -> None: ...
    def clear_int_prod(self) -> None: ...
    def clear_interval(self) -> None: ...
    def clear_inverse(self) -> None: ...
    def clear_lin_max(self) -> None: ...
    def clear_linear(self) -> None: ...
    def clear_name(self) -> None: ...
    def clear_no_overlap(self) -> None: ...
    def clear_no_overlap_2d(self) -> None: ...
    def clear_reservoir(self) -> None: ...
    def clear_routes(self) -> None: ...
    def clear_table(self) -> None: ...
    def copy_from(self, arg0: ConstraintProto) -> None: ...
    def has_all_diff(self) -> bool: ...
    def has_at_most_one(self) -> bool: ...
    def has_automaton(self) -> bool: ...
    def has_bool_and(self) -> bool: ...
    def has_bool_or(self) -> bool: ...
    def has_bool_xor(self) -> bool: ...
    def has_circuit(self) -> bool: ...
    def has_cumulative(self) -> bool: ...
    def has_dummy_constraint(self) -> bool: ...
    def has_element(self) -> bool: ...
    def has_exactly_one(self) -> bool: ...
    def has_int_div(self) -> bool: ...
    def has_int_mod(self) -> bool: ...
    def has_int_prod(self) -> bool: ...
    def has_interval(self) -> bool: ...
    def has_inverse(self) -> bool: ...
    def has_lin_max(self) -> bool: ...
    def has_linear(self) -> bool: ...
    def has_no_overlap(self) -> bool: ...
    def has_no_overlap_2d(self) -> bool: ...
    def has_reservoir(self) -> bool: ...
    def has_routes(self) -> bool: ...
    def has_table(self) -> bool: ...
    def merge_from(self, arg0: ConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> ConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> ConstraintProto: ...
    @property
    def enforcement_literal(self): ...

class CpBaseModel:
    def __init__(self, arg0) -> None: ...
    def get_or_make_boolean_index(self, value: object) -> int: ...
    def get_or_make_index_from_constant(self, value: int) -> int: ...
    def get_or_make_variable_index(self, arg: object) -> int: ...
    def is_boolean_value(self, value: object) -> bool: ...
    def rebuild_constant_map(self) -> None: ...
    @property
    def model_proto(self): ...

class CpModelProto:
    floating_point_objective: Incomplete
    name: str
    objective: CpObjectiveProto
    solution_hint: Incomplete
    symmetry: Incomplete
    def __init__(self) -> None: ...
    def clear_floating_point_objective(self) -> None: ...
    def clear_name(self) -> None: ...
    def clear_objective(self) -> None: ...
    def clear_solution_hint(self) -> None: ...
    def clear_symmetry(self) -> None: ...
    def copy_from(self, arg0: CpModelProto) -> None: ...
    def has_floating_point_objective(self) -> bool: ...
    def has_objective(self) -> bool: ...
    def has_solution_hint(self) -> bool: ...
    def has_symmetry(self) -> bool: ...
    def merge_from(self, arg0: CpModelProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> CpModelProto: ...
    def __deepcopy__(self, arg0: dict) -> CpModelProto: ...
    @property
    def assumptions(self): ...
    @property
    def constraints(self): ...
    @property
    def search_strategy(self): ...
    @property
    def variables(self): ...

class CpObjectiveProto:
    integer_after_offset: int
    integer_before_offset: int
    integer_scaling_factor: int
    offset: float
    scaling_factor: float
    scaling_was_exact: bool
    def __init__(self) -> None: ...
    def clear_integer_after_offset(self) -> None: ...
    def clear_integer_before_offset(self) -> None: ...
    def clear_integer_scaling_factor(self) -> None: ...
    def clear_offset(self) -> None: ...
    def clear_scaling_factor(self) -> None: ...
    def clear_scaling_was_exact(self) -> None: ...
    def copy_from(self, arg0: CpObjectiveProto) -> None: ...
    def merge_from(self, arg0: CpObjectiveProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> CpObjectiveProto: ...
    def __deepcopy__(self, arg0: dict) -> CpObjectiveProto: ...
    @property
    def coeffs(self): ...
    @property
    def domain(self): ...
    @property
    def vars(self): ...

class CpSatHelper:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def model_stats(model_proto) -> str: ...
    @staticmethod
    def solver_response_stats(response) -> str: ...
    @staticmethod
    def validate_model(model_proto) -> str: ...
    @staticmethod
    def write_model_to_file(model_proto, filename: str) -> bool: ...

class CpSolverResponse:
    best_objective_bound: float
    deterministic_time: float
    gap_integral: float
    inner_objective_lower_bound: int
    integer_objective: Incomplete
    num_binary_propagations: int
    num_booleans: int
    num_branches: int
    num_conflicts: int
    num_fixed_booleans: int
    num_integer_propagations: int
    num_integers: int
    num_lp_iterations: int
    num_restarts: int
    objective_value: float
    solution_info: str
    solve_log: str
    status: Incomplete
    user_time: float
    wall_time: float
    def __init__(self) -> None: ...
    def clear_best_objective_bound(self) -> None: ...
    def clear_deterministic_time(self) -> None: ...
    def clear_gap_integral(self) -> None: ...
    def clear_inner_objective_lower_bound(self) -> None: ...
    def clear_integer_objective(self) -> None: ...
    def clear_num_binary_propagations(self) -> None: ...
    def clear_num_booleans(self) -> None: ...
    def clear_num_branches(self) -> None: ...
    def clear_num_conflicts(self) -> None: ...
    def clear_num_fixed_booleans(self) -> None: ...
    def clear_num_integer_propagations(self) -> None: ...
    def clear_num_integers(self) -> None: ...
    def clear_num_lp_iterations(self) -> None: ...
    def clear_num_restarts(self) -> None: ...
    def clear_objective_value(self) -> None: ...
    def clear_solution_info(self) -> None: ...
    def clear_solve_log(self) -> None: ...
    def clear_status(self) -> None: ...
    def clear_user_time(self) -> None: ...
    def clear_wall_time(self) -> None: ...
    def copy_from(self, arg0: CpSolverResponse) -> None: ...
    def has_integer_objective(self) -> bool: ...
    def merge_from(self, arg0: CpSolverResponse) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> CpSolverResponse: ...
    def __deepcopy__(self, arg0: dict) -> CpSolverResponse: ...
    @property
    def additional_solutions(self): ...
    @property
    def solution(self): ...
    @property
    def sufficient_assumptions_for_infeasibility(self): ...
    @property
    def tightened_variables(self): ...

class CpSolverSolution:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: CpSolverSolution) -> None: ...
    def merge_from(self, arg0: CpSolverSolution) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> CpSolverSolution: ...
    def __deepcopy__(self, arg0: dict) -> CpSolverSolution: ...
    @property
    def values(self): ...

class CpSolverStatus:
    __members__: ClassVar[dict] = ...  # read-only
    FEASIBLE: ClassVar[CpSolverStatus] = ...
    INFEASIBLE: ClassVar[CpSolverStatus] = ...
    MODEL_INVALID: ClassVar[CpSolverStatus] = ...
    OPTIMAL: ClassVar[CpSolverStatus] = ...
    UNKNOWN: ClassVar[CpSolverStatus] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CumulativeConstraintProto:
    capacity: LinearExpressionProto
    def __init__(self) -> None: ...
    def clear_capacity(self) -> None: ...
    def copy_from(self, arg0: CumulativeConstraintProto) -> None: ...
    def has_capacity(self) -> bool: ...
    def merge_from(self, arg0: CumulativeConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> CumulativeConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> CumulativeConstraintProto: ...
    @property
    def demands(self): ...
    @property
    def intervals(self): ...

class DecisionStrategyProto:
    class DomainReductionStrategy:
        __members__: ClassVar[dict] = ...  # read-only
        SELECT_LOWER_HALF: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
        SELECT_MAX_VALUE: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
        SELECT_MEDIAN_VALUE: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
        SELECT_MIN_VALUE: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
        SELECT_RANDOM_HALF: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
        SELECT_UPPER_HALF: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class VariableSelectionStrategy:
        __members__: ClassVar[dict] = ...  # read-only
        CHOOSE_FIRST: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
        CHOOSE_HIGHEST_MAX: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
        CHOOSE_LOWEST_MIN: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
        CHOOSE_MAX_DOMAIN_SIZE: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
        CHOOSE_MIN_DOMAIN_SIZE: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    CHOOSE_FIRST: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
    CHOOSE_HIGHEST_MAX: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
    CHOOSE_LOWEST_MIN: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
    CHOOSE_MAX_DOMAIN_SIZE: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
    CHOOSE_MIN_DOMAIN_SIZE: ClassVar[DecisionStrategyProto.VariableSelectionStrategy] = ...
    SELECT_LOWER_HALF: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
    SELECT_MAX_VALUE: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
    SELECT_MEDIAN_VALUE: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
    SELECT_MIN_VALUE: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
    SELECT_RANDOM_HALF: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
    SELECT_UPPER_HALF: ClassVar[DecisionStrategyProto.DomainReductionStrategy] = ...
    domain_reduction_strategy: Incomplete
    variable_selection_strategy: Incomplete
    def __init__(self) -> None: ...
    def clear_domain_reduction_strategy(self) -> None: ...
    def clear_variable_selection_strategy(self) -> None: ...
    def copy_from(self, arg0: DecisionStrategyProto) -> None: ...
    def merge_from(self, arg0: DecisionStrategyProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> DecisionStrategyProto: ...
    def __deepcopy__(self, arg0: dict) -> DecisionStrategyProto: ...
    @property
    def exprs(self): ...
    @property
    def variables(self): ...

class DenseMatrixProto:
    num_cols: int
    num_rows: int
    def __init__(self) -> None: ...
    def clear_num_cols(self) -> None: ...
    def clear_num_rows(self) -> None: ...
    def copy_from(self, arg0: DenseMatrixProto) -> None: ...
    def merge_from(self, arg0: DenseMatrixProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> DenseMatrixProto: ...
    def __deepcopy__(self, arg0: dict) -> DenseMatrixProto: ...
    @property
    def entries(self): ...

class ElementConstraintProto:
    index: int
    linear_index: LinearExpressionProto
    linear_target: LinearExpressionProto
    target: int
    def __init__(self) -> None: ...
    def clear_index(self) -> None: ...
    def clear_linear_index(self) -> None: ...
    def clear_linear_target(self) -> None: ...
    def clear_target(self) -> None: ...
    def copy_from(self, arg0: ElementConstraintProto) -> None: ...
    def has_linear_index(self) -> bool: ...
    def has_linear_target(self) -> bool: ...
    def merge_from(self, arg0: ElementConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> ElementConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> ElementConstraintProto: ...
    @property
    def exprs(self): ...
    @property
    def vars(self): ...

class FlatFloatExpr(LinearExpr):
    def __init__(self, arg0: LinearExpr) -> None: ...
    @property
    def coeffs(self) -> list[float]: ...
    @property
    def offset(self) -> float: ...
    @property
    def vars(self): ...

class FlatIntExpr(LinearExpr):
    def __init__(self, arg0: LinearExpr) -> None: ...
    @property
    def coeffs(self) -> list[int]: ...
    @property
    def offset(self) -> int: ...
    @property
    def ok(self) -> bool: ...
    @property
    def vars(self): ...

class FloatAffine(LinearExpr):
    def __init__(self, arg0: LinearExpr, arg1: float, arg2: float) -> None: ...
    @property
    def coefficient(self) -> float: ...
    @property
    def expression(self) -> LinearExpr: ...
    @property
    def offset(self) -> float: ...

class FloatObjectiveProto:
    maximize: bool
    offset: float
    def __init__(self) -> None: ...
    def clear_maximize(self) -> None: ...
    def clear_offset(self) -> None: ...
    def copy_from(self, arg0: FloatObjectiveProto) -> None: ...
    def merge_from(self, arg0: FloatObjectiveProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> FloatObjectiveProto: ...
    def __deepcopy__(self, arg0: dict) -> FloatObjectiveProto: ...
    @property
    def coeffs(self): ...
    @property
    def vars(self): ...

class IntAffine(LinearExpr):
    def __init__(self, arg0: LinearExpr, arg1: int, arg2: int) -> None: ...
    @property
    def coefficient(self) -> int: ...
    @property
    def expression(self) -> LinearExpr: ...
    @property
    def offset(self) -> int: ...

class IntVar(Literal):
    domain: ortools.util.python.sorted_interval_list.Domain
    name: str
    @overload
    def __init__(self, arg0, arg1: int) -> None: ...
    @overload
    def __init__(self, arg0) -> None: ...
    def Index(self) -> int: ...
    def Name(self) -> str: ...
    def Not(self) -> Literal: ...
    def Proto(self, *args, **kwargs): ...
    def negated(self) -> Literal: ...
    def with_domain(self, domain: ortools.util.python.sorted_interval_list.Domain) -> IntVar: ...
    def with_name(self, name: str) -> IntVar: ...
    def __copy__(self) -> IntVar: ...
    def __invert__(self) -> Literal: ...
    @property
    def index(self) -> int: ...
    @property
    def is_boolean(self) -> bool: ...
    @property
    def model_proto(self): ...
    @property
    def proto(self): ...

class IntegerVariableProto:
    name: str
    def __init__(self) -> None: ...
    def clear_name(self) -> None: ...
    def copy_from(self, arg0: IntegerVariableProto) -> None: ...
    def merge_from(self, arg0: IntegerVariableProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> IntegerVariableProto: ...
    def __deepcopy__(self, arg0: dict) -> IntegerVariableProto: ...
    @property
    def domain(self): ...

class IntervalConstraintProto:
    end: LinearExpressionProto
    size: LinearExpressionProto
    start: LinearExpressionProto
    def __init__(self) -> None: ...
    def clear_end(self) -> None: ...
    def clear_size(self) -> None: ...
    def clear_start(self) -> None: ...
    def copy_from(self, arg0: IntervalConstraintProto) -> None: ...
    def has_end(self) -> bool: ...
    def has_size(self) -> bool: ...
    def has_start(self) -> bool: ...
    def merge_from(self, arg0: IntervalConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> IntervalConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> IntervalConstraintProto: ...

class IntervalVar:
    name: str
    def __init__(self, arg0, arg1: int) -> None: ...
    def EndExpr(self) -> object: ...
    def Index(self) -> int: ...
    def Name(self) -> str: ...
    def Proto(self, *args, **kwargs): ...
    def SizeExpr(self) -> object: ...
    def StartExpr(self) -> object: ...
    def end_expr(self) -> object: ...
    def presence_literals(self) -> list[Literal]: ...
    def size_expr(self) -> object: ...
    def start_expr(self) -> object: ...
    @property
    def index(self) -> int: ...
    @property
    def model_proto(self): ...
    @property
    def proto(self): ...

class InverseConstraintProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: InverseConstraintProto) -> None: ...
    def merge_from(self, arg0: InverseConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> InverseConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> InverseConstraintProto: ...
    @property
    def f_direct(self): ...
    @property
    def f_inverse(self): ...

class LinearArgumentConstraint:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    div: ClassVar[LinearArgumentConstraint] = ...
    max: ClassVar[LinearArgumentConstraint] = ...
    min: ClassVar[LinearArgumentConstraint] = ...
    mod: ClassVar[LinearArgumentConstraint] = ...
    prod: ClassVar[LinearArgumentConstraint] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LinearArgumentProto:
    target: LinearExpressionProto
    def __init__(self) -> None: ...
    def clear_target(self) -> None: ...
    def copy_from(self, arg0: LinearArgumentProto) -> None: ...
    def has_target(self) -> bool: ...
    def merge_from(self, arg0: LinearArgumentProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> LinearArgumentProto: ...
    def __deepcopy__(self, arg0: dict) -> LinearArgumentProto: ...
    @property
    def exprs(self): ...

class LinearConstraintProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: LinearConstraintProto) -> None: ...
    def merge_from(self, arg0: LinearConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> LinearConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> LinearConstraintProto: ...
    @property
    def coeffs(self): ...
    @property
    def domain(self): ...
    @property
    def vars(self): ...

class LinearExpr:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def Sum(*args) -> LinearExpr: ...
    @overload
    @staticmethod
    def Term(expr: LinearExpr, coeff: int) -> LinearExpr: ...
    @overload
    @staticmethod
    def Term(expr: LinearExpr, coeff: float) -> LinearExpr: ...
    @staticmethod
    def WeightedSum(expressions: Sequence, coefficients: Sequence) -> LinearExpr: ...
    @overload
    @staticmethod
    def affine(expr: LinearExpr, coeff: int, offset: int) -> LinearExpr: ...
    @overload
    @staticmethod
    def affine(expr: LinearExpr, coeff: float, offset: float) -> LinearExpr: ...
    @overload
    @staticmethod
    def constant(value: int) -> LinearExpr: ...
    @overload
    @staticmethod
    def constant(value: float) -> LinearExpr: ...
    def is_integer(self) -> bool: ...
    @overload
    @staticmethod
    def sum(*args) -> LinearExpr: ...
    @overload
    @staticmethod
    def sum(expressions) -> Any: ...
    @overload
    @staticmethod
    def term(expr: LinearExpr, coeff: int) -> LinearExpr: ...
    @overload
    @staticmethod
    def term(expr: LinearExpr, coeff: float) -> LinearExpr: ...
    @staticmethod
    def weighted_sum(expressions: Sequence, coefficients: Sequence) -> LinearExpr: ...
    def __abs__(self) -> None: ...
    @overload
    def __add__(self, other: LinearExpr) -> LinearExpr: ...
    @overload
    def __add__(self, cst: int) -> LinearExpr: ...
    @overload
    def __add__(self, cst: float) -> LinearExpr: ...
    def __and__(self, arg0: object) -> None: ...
    def __bool__(self) -> None: ...
    def __div__(self, arg0: object) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lshift__(self, arg0: object) -> None: ...
    def __lt__(self, other: object) -> bool: ...
    def __mod__(self, arg0: object) -> None: ...
    @overload
    def __mul__(self, cst: int) -> LinearExpr: ...
    @overload
    def __mul__(self, cst: float) -> LinearExpr: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> LinearExpr: ...
    def __or__(self, arg0: object) -> None: ...
    def __pow__(self, arg0: object) -> None: ...
    @overload
    def __radd__(self, cst: int) -> LinearExpr: ...
    @overload
    def __radd__(self, cst: float) -> LinearExpr: ...
    @overload
    def __rmul__(self, cst: int) -> LinearExpr: ...
    @overload
    def __rmul__(self, cst: float) -> LinearExpr: ...
    def __rshift__(self, arg0: object) -> None: ...
    @overload
    def __rsub__(self, other: LinearExpr) -> LinearExpr: ...
    @overload
    def __rsub__(self, cst: int) -> LinearExpr: ...
    @overload
    def __rsub__(self, cst: float) -> LinearExpr: ...
    @overload
    def __sub__(self, h: LinearExpr) -> LinearExpr: ...
    @overload
    def __sub__(self, cst: int) -> LinearExpr: ...
    @overload
    def __sub__(self, cst: float) -> LinearExpr: ...
    def __truediv__(self, arg0: object) -> None: ...
    def __xor__(self, arg0: object) -> None: ...

class LinearExpressionProto:
    offset: int
    def __init__(self) -> None: ...
    def clear_offset(self) -> None: ...
    def copy_from(self, arg0: LinearExpressionProto) -> None: ...
    def merge_from(self, arg0: LinearExpressionProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> LinearExpressionProto: ...
    def __deepcopy__(self, arg0: dict) -> LinearExpressionProto: ...
    @property
    def coeffs(self): ...
    @property
    def vars(self): ...

class ListOfVariablesProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: ListOfVariablesProto) -> None: ...
    def merge_from(self, arg0: ListOfVariablesProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> ListOfVariablesProto: ...
    def __deepcopy__(self, arg0: dict) -> ListOfVariablesProto: ...
    @property
    def vars(self): ...

class Literal(LinearExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    def Index(self) -> int: ...
    def Not(self) -> Literal: ...
    @overload
    def negated(self) -> Literal: ...
    @overload
    def negated(self) -> Any: ...
    def __bool__(self) -> None: ...
    def __hash__(self) -> int: ...
    def __invert__(self) -> Literal: ...
    @property
    def index(self) -> int: ...

class NoOverlap2DConstraintProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: NoOverlap2DConstraintProto) -> None: ...
    def merge_from(self, arg0: NoOverlap2DConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> NoOverlap2DConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> NoOverlap2DConstraintProto: ...
    @property
    def x_intervals(self): ...
    @property
    def y_intervals(self): ...

class NoOverlapConstraintProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: NoOverlapConstraintProto) -> None: ...
    def merge_from(self, arg0: NoOverlapConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> NoOverlapConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> NoOverlapConstraintProto: ...
    @property
    def intervals(self): ...

class NotBooleanVariable(Literal):
    def __init__(self, *args, **kwargs) -> None: ...
    def Not(self) -> Literal: ...
    def negated(self) -> Literal: ...
    def __invert__(self) -> Literal: ...
    @property
    def index(self) -> int: ...

class PartialVariableAssignment:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: PartialVariableAssignment) -> None: ...
    def merge_from(self, arg0: PartialVariableAssignment) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> PartialVariableAssignment: ...
    def __deepcopy__(self, arg0: dict) -> PartialVariableAssignment: ...
    @property
    def values(self): ...
    @property
    def vars(self): ...

class ReservoirConstraintProto:
    max_level: int
    min_level: int
    def __init__(self) -> None: ...
    def clear_max_level(self) -> None: ...
    def clear_min_level(self) -> None: ...
    def copy_from(self, arg0: ReservoirConstraintProto) -> None: ...
    def merge_from(self, arg0: ReservoirConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> ReservoirConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> ReservoirConstraintProto: ...
    @property
    def active_literals(self): ...
    @property
    def level_changes(self): ...
    @property
    def time_exprs(self): ...

class ResponseHelper:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    @staticmethod
    def boolean_value(response, lit) -> bool: ...
    @overload
    @staticmethod
    def boolean_value(response, lit: bool) -> bool: ...
    @overload
    @staticmethod
    def float_value(response, expr) -> float: ...
    @overload
    @staticmethod
    def float_value(response, value: float) -> float: ...
    @staticmethod
    def sufficient_assumptions_for_infeasibility(response) -> list[int]: ...
    @overload
    @staticmethod
    def value(response, expr) -> int: ...
    @overload
    @staticmethod
    def value(response, value: int) -> int: ...

class RoutesConstraintProto:
    class NodeExpressions:
        def __init__(self) -> None: ...
        def copy_from(self, arg0: RoutesConstraintProto.NodeExpressions) -> None: ...
        def merge_from(self, arg0: RoutesConstraintProto.NodeExpressions) -> None: ...
        def merge_text_format(self, arg0: str) -> bool: ...
        def parse_text_format(self, arg0: str) -> bool: ...
        def __copy__(self) -> RoutesConstraintProto.NodeExpressions: ...
        def __deepcopy__(self, arg0: dict) -> RoutesConstraintProto.NodeExpressions: ...
        @property
        def exprs(self): ...
    capacity: int
    def __init__(self) -> None: ...
    def clear_capacity(self) -> None: ...
    def copy_from(self, arg0: RoutesConstraintProto) -> None: ...
    def merge_from(self, arg0: RoutesConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> RoutesConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> RoutesConstraintProto: ...
    @property
    def demands(self): ...
    @property
    def dimensions(self): ...
    @property
    def heads(self): ...
    @property
    def literals(self): ...
    @property
    def tails(self): ...

class SatParameters:
    class BinaryMinizationAlgorithm:
        __members__: ClassVar[dict] = ...  # read-only
        BINARY_MINIMIZATION_FROM_UIP: ClassVar[SatParameters.BinaryMinizationAlgorithm] = ...
        BINARY_MINIMIZATION_FROM_UIP_AND_DECISIONS: ClassVar[SatParameters.BinaryMinizationAlgorithm] = ...
        NO_BINARY_MINIMIZATION: ClassVar[SatParameters.BinaryMinizationAlgorithm] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ClauseOrdering:
        __members__: ClassVar[dict] = ...  # read-only
        CLAUSE_ACTIVITY: ClassVar[SatParameters.ClauseOrdering] = ...
        CLAUSE_LBD: ClassVar[SatParameters.ClauseOrdering] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ConflictMinimizationAlgorithm:
        __members__: ClassVar[dict] = ...  # read-only
        NONE: ClassVar[SatParameters.ConflictMinimizationAlgorithm] = ...
        RECURSIVE: ClassVar[SatParameters.ConflictMinimizationAlgorithm] = ...
        SIMPLE: ClassVar[SatParameters.ConflictMinimizationAlgorithm] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FPRoundingMethod:
        __members__: ClassVar[dict] = ...  # read-only
        ACTIVE_LOCK_BASED: ClassVar[SatParameters.FPRoundingMethod] = ...
        LOCK_BASED: ClassVar[SatParameters.FPRoundingMethod] = ...
        NEAREST_INTEGER: ClassVar[SatParameters.FPRoundingMethod] = ...
        PROPAGATION_ASSISTED: ClassVar[SatParameters.FPRoundingMethod] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class MaxSatAssumptionOrder:
        __members__: ClassVar[dict] = ...  # read-only
        DEFAULT_ASSUMPTION_ORDER: ClassVar[SatParameters.MaxSatAssumptionOrder] = ...
        ORDER_ASSUMPTION_BY_DEPTH: ClassVar[SatParameters.MaxSatAssumptionOrder] = ...
        ORDER_ASSUMPTION_BY_WEIGHT: ClassVar[SatParameters.MaxSatAssumptionOrder] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class MaxSatStratificationAlgorithm:
        __members__: ClassVar[dict] = ...  # read-only
        STRATIFICATION_ASCENT: ClassVar[SatParameters.MaxSatStratificationAlgorithm] = ...
        STRATIFICATION_DESCENT: ClassVar[SatParameters.MaxSatStratificationAlgorithm] = ...
        STRATIFICATION_NONE: ClassVar[SatParameters.MaxSatStratificationAlgorithm] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Polarity:
        __members__: ClassVar[dict] = ...  # read-only
        POLARITY_FALSE: ClassVar[SatParameters.Polarity] = ...
        POLARITY_RANDOM: ClassVar[SatParameters.Polarity] = ...
        POLARITY_TRUE: ClassVar[SatParameters.Polarity] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SearchBranching:
        __members__: ClassVar[dict] = ...  # read-only
        AUTOMATIC_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        FIXED_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        HINT_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        LP_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        PARTIAL_FIXED_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        PORTFOLIO_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        PORTFOLIO_WITH_QUICK_RESTART_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        PSEUDO_COST_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        RANDOMIZED_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SharedTreeSplitStrategy:
        __members__: ClassVar[dict] = ...  # read-only
        SPLIT_STRATEGY_AUTO: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
        SPLIT_STRATEGY_BALANCED_TREE: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
        SPLIT_STRATEGY_DISCREPANCY: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
        SPLIT_STRATEGY_FIRST_PROPOSAL: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
        SPLIT_STRATEGY_OBJECTIVE_LB: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class VariableOrder:
        __members__: ClassVar[dict] = ...  # read-only
        IN_ORDER: ClassVar[SatParameters.VariableOrder] = ...
        IN_RANDOM_ORDER: ClassVar[SatParameters.VariableOrder] = ...
        IN_REVERSE_ORDER: ClassVar[SatParameters.VariableOrder] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    ACTIVE_LOCK_BASED: ClassVar[SatParameters.FPRoundingMethod] = ...
    AUTOMATIC_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    BINARY_MINIMIZATION_FROM_UIP: ClassVar[SatParameters.BinaryMinizationAlgorithm] = ...
    BINARY_MINIMIZATION_FROM_UIP_AND_DECISIONS: ClassVar[SatParameters.BinaryMinizationAlgorithm] = ...
    CLAUSE_ACTIVITY: ClassVar[SatParameters.ClauseOrdering] = ...
    CLAUSE_LBD: ClassVar[SatParameters.ClauseOrdering] = ...
    DEFAULT_ASSUMPTION_ORDER: ClassVar[SatParameters.MaxSatAssumptionOrder] = ...
    FIXED_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    HINT_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    IN_ORDER: ClassVar[SatParameters.VariableOrder] = ...
    IN_RANDOM_ORDER: ClassVar[SatParameters.VariableOrder] = ...
    IN_REVERSE_ORDER: ClassVar[SatParameters.VariableOrder] = ...
    LOCK_BASED: ClassVar[SatParameters.FPRoundingMethod] = ...
    LP_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    NEAREST_INTEGER: ClassVar[SatParameters.FPRoundingMethod] = ...
    NONE: ClassVar[SatParameters.ConflictMinimizationAlgorithm] = ...
    NO_BINARY_MINIMIZATION: ClassVar[SatParameters.BinaryMinizationAlgorithm] = ...
    ORDER_ASSUMPTION_BY_DEPTH: ClassVar[SatParameters.MaxSatAssumptionOrder] = ...
    ORDER_ASSUMPTION_BY_WEIGHT: ClassVar[SatParameters.MaxSatAssumptionOrder] = ...
    PARTIAL_FIXED_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    POLARITY_FALSE: ClassVar[SatParameters.Polarity] = ...
    POLARITY_RANDOM: ClassVar[SatParameters.Polarity] = ...
    POLARITY_TRUE: ClassVar[SatParameters.Polarity] = ...
    PORTFOLIO_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    PORTFOLIO_WITH_QUICK_RESTART_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    PROPAGATION_ASSISTED: ClassVar[SatParameters.FPRoundingMethod] = ...
    PSEUDO_COST_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    RANDOMIZED_SEARCH: ClassVar[SatParameters.SearchBranching] = ...
    RECURSIVE: ClassVar[SatParameters.ConflictMinimizationAlgorithm] = ...
    SIMPLE: ClassVar[SatParameters.ConflictMinimizationAlgorithm] = ...
    SPLIT_STRATEGY_AUTO: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
    SPLIT_STRATEGY_BALANCED_TREE: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
    SPLIT_STRATEGY_DISCREPANCY: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
    SPLIT_STRATEGY_FIRST_PROPOSAL: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
    SPLIT_STRATEGY_OBJECTIVE_LB: ClassVar[SatParameters.SharedTreeSplitStrategy] = ...
    STRATIFICATION_ASCENT: ClassVar[SatParameters.MaxSatStratificationAlgorithm] = ...
    STRATIFICATION_DESCENT: ClassVar[SatParameters.MaxSatStratificationAlgorithm] = ...
    STRATIFICATION_NONE: ClassVar[SatParameters.MaxSatStratificationAlgorithm] = ...
    absolute_gap_limit: float
    add_cg_cuts: bool
    add_clique_cuts: bool
    add_lin_max_cuts: bool
    add_lp_constraints_lazily: bool
    add_mir_cuts: bool
    add_objective_cut: bool
    add_rlt_cuts: bool
    add_zero_half_cuts: bool
    also_bump_variables_in_conflict_reasons: bool
    alternative_pool_size: int
    at_most_one_max_expansion_size: int
    auto_detect_greater_than_at_least_one_of: bool
    binary_minimization_algorithm: Incomplete
    binary_search_num_conflicts: int
    blocking_restart_multiplier: float
    blocking_restart_window_size: int
    boolean_encoding_level: int
    catch_sigint_signal: bool
    check_drat_proof: bool
    check_lrat_proof: bool
    check_merged_lrat_proof: bool
    chronological_backtrack_min_conflicts: int
    clause_activity_decay: float
    clause_cleanup_lbd_bound: int
    clause_cleanup_lbd_tier1: int
    clause_cleanup_lbd_tier2: int
    clause_cleanup_ordering: Incomplete
    clause_cleanup_period: int
    clause_cleanup_period_increment: int
    clause_cleanup_ratio: float
    clause_cleanup_target: int
    convert_intervals: bool
    core_minimization_level: int
    count_assumption_levels_in_lbd: bool
    cover_optimization: bool
    cp_model_presolve: bool
    cp_model_probing_level: int
    cp_model_use_sat_presolve: bool
    create_1uip_boolean_during_icr: bool
    cut_active_count_decay: float
    cut_cleanup_target: int
    cut_level: int
    cut_max_active_count_value: float
    debug_crash_if_lrat_check_fails: bool
    debug_crash_if_presolve_breaks_hint: bool
    debug_crash_on_bad_hint: bool
    debug_max_num_presolve_operations: int
    debug_postsolve_with_full_solver: bool
    decision_subsumption_during_conflict_analysis: bool
    default_restart_algorithms: str
    detect_linearized_product: bool
    detect_table_with_cost: bool
    disable_constraint_expansion: bool
    diversify_lns_params: bool
    eagerly_subsume_last_n_conflicts: int
    encode_complex_linear_constraint_with_integer: bool
    encode_cumulative_as_reservoir: bool
    enumerate_all_solutions: bool
    expand_alldiff_constraints: bool
    expand_reservoir_constraints: bool
    expand_reservoir_using_circuit: bool
    exploit_all_lp_solution: bool
    exploit_all_precedences: bool
    exploit_best_solution: bool
    exploit_integer_lp_solution: bool
    exploit_objective: bool
    exploit_relaxation_solution: bool
    extra_subsumption_during_conflict_analysis: bool
    feasibility_jump_batch_dtime: float
    feasibility_jump_decay: float
    feasibility_jump_enable_restarts: bool
    feasibility_jump_linearization_level: int
    feasibility_jump_max_expanded_constraint_size: int
    feasibility_jump_restart_factor: int
    feasibility_jump_var_perburbation_range_ratio: float
    feasibility_jump_var_randomization_probability: float
    fill_additional_solutions_in_response: bool
    fill_tightened_domains_in_response: bool
    filter_sat_postsolve_clauses: bool
    find_big_linear_overlap: bool
    find_clauses_that_are_exactly_one: bool
    find_multiple_cores: bool
    fix_variables_to_their_hinted_value: bool
    fp_rounding: Incomplete
    glucose_decay_increment: float
    glucose_decay_increment_period: int
    glucose_max_decay: float
    hint_conflict_limit: int
    ignore_names: bool
    infer_all_diffs: bool
    initial_polarity: Incomplete
    initial_variables_activity: float
    inprocessing_dtime_ratio: float
    inprocessing_minimization_dtime: float
    inprocessing_minimization_use_all_orderings: bool
    inprocessing_minimization_use_conflict_analysis: bool
    inprocessing_probing_dtime: float
    inprocessing_use_congruence_closure: bool
    inprocessing_use_sat_sweeping: bool
    instantiate_all_variables: bool
    interleave_batch_size: int
    interleave_search: bool
    keep_all_feasible_solutions_in_presolve: bool
    keep_symmetry_in_presolve: bool
    lb_relax_num_workers_threshold: int
    linear_split_size: int
    linearization_level: int
    lns_initial_deterministic_limit: float
    lns_initial_difficulty: float
    load_at_most_ones_in_sat_presolve: bool
    log_prefix: str
    log_search_progress: bool
    log_subsolver_statistics: bool
    log_to_response: bool
    log_to_stdout: bool
    lp_dual_tolerance: float
    lp_primal_tolerance: float
    max_all_diff_cut_size: int
    max_alldiff_domain_size: int
    max_backjump_levels: int
    max_clause_activity_value: float
    max_consecutive_inactive_count: int
    max_cut_rounds_at_level_zero: int
    max_deterministic_time: float
    max_domain_size_for_linear2_expansion: int
    max_domain_size_when_encoding_eq_neq_constraints: int
    max_drat_time_in_seconds: float
    max_integer_rounding_scaling: int
    max_lin_max_size_for_expansion: int
    max_memory_in_mb: int
    max_num_cuts: int
    max_num_deterministic_batches: int
    max_num_intervals_for_timetable_edge_finding: int
    max_number_of_conflicts: int
    max_pairs_pairwise_reasoning_in_no_overlap_2d: int
    max_presolve_iterations: int
    max_sat_assumption_order: Incomplete
    max_sat_reverse_assumption_order: bool
    max_sat_stratification: Incomplete
    max_size_to_create_precedence_literals_in_disjunctive: int
    max_time_in_seconds: float
    max_variable_activity_value: float
    maximum_regions_to_split_in_disconnected_no_overlap_2d: int
    merge_at_most_one_work_limit: float
    merge_no_overlap_work_limit: float
    min_orthogonality_for_lp_constraints: float
    minimization_algorithm: Incomplete
    minimize_reduction_during_pb_resolution: bool
    minimize_shared_clauses: bool
    mip_automatically_scale_variables: bool
    mip_check_precision: float
    mip_compute_true_objective_bound: bool
    mip_drop_tolerance: float
    mip_max_activity_exponent: int
    mip_max_bound: float
    mip_max_valid_magnitude: float
    mip_presolve_level: int
    mip_scale_large_domain: bool
    mip_treat_high_magnitude_bounds_as_infinity: bool
    mip_var_scaling: float
    mip_wanted_precision: float
    name: str
    new_constraints_batch_size: int
    new_linear_propagation: bool
    no_overlap_2d_boolean_relations_limit: int
    num_conflicts_before_strategy_changes: int
    num_full_subsolvers: int
    num_search_workers: int
    num_violation_ls: int
    num_workers: int
    only_add_cuts_at_level_zero: bool
    only_solve_ip: bool
    optimize_with_core: bool
    optimize_with_lb_tree_search: bool
    optimize_with_max_hs: bool
    output_drat_proof: bool
    output_lrat_proof: bool
    pb_cleanup_increment: int
    pb_cleanup_ratio: float
    permute_presolve_constraint_order: bool
    permute_variable_randomly: bool
    polarity_exploit_ls_hints: bool
    polarity_rephase_increment: int
    polish_lp_solution: bool
    preferred_variable_order: Incomplete
    presolve_blocked_clause: bool
    presolve_bva_threshold: int
    presolve_bve_clause_weight: int
    presolve_bve_threshold: int
    presolve_extract_integer_enforcement: bool
    presolve_inclusion_work_limit: int
    presolve_probing_deterministic_time_limit: float
    presolve_substitution_level: int
    presolve_use_bva: bool
    probing_deterministic_time_limit: float
    probing_num_combinations_limit: int
    propagation_loop_detection_factor: float
    pseudo_cost_reliability_threshold: int
    push_all_tasks_toward_start: bool
    random_branches_ratio: float
    random_polarity_ratio: float
    random_seed: int
    randomize_search: bool
    relative_gap_limit: float
    remove_fixed_variables_early: bool
    repair_hint: bool
    restart_dl_average_ratio: float
    restart_lbd_average_ratio: float
    restart_period: int
    restart_running_window_size: int
    root_lp_iterations: int
    routing_cut_dp_effort: float
    routing_cut_max_infeasible_path_length: int
    routing_cut_subset_size_for_binary_relation_bound: int
    routing_cut_subset_size_for_exact_binary_relation_bound: int
    routing_cut_subset_size_for_shortest_paths_bound: int
    routing_cut_subset_size_for_tight_binary_relation_bound: int
    save_lp_basis_in_lb_tree_search: bool
    search_branching: Incomplete
    search_random_variable_pool_size: int
    share_binary_clauses: bool
    share_glue_clauses: bool
    share_glue_clauses_dtime: float
    share_level_zero_bounds: bool
    share_linear2_bounds: bool
    share_objective_bounds: bool
    shared_tree_balance_tolerance: int
    shared_tree_max_nodes_per_worker: int
    shared_tree_num_workers: int
    shared_tree_open_leaves_per_worker: float
    shared_tree_split_min_dtime: float
    shared_tree_split_strategy: Incomplete
    shared_tree_worker_enable_phase_sharing: bool
    shared_tree_worker_enable_trail_sharing: bool
    shared_tree_worker_min_restarts_per_subtree: int
    shaving_deterministic_time_in_probing_search: float
    shaving_search_deterministic_time: float
    shaving_search_threshold: int
    solution_pool_diversity_limit: int
    solution_pool_size: int
    stop_after_first_solution: bool
    stop_after_presolve: bool
    stop_after_root_propagation: bool
    strategy_change_increase_ratio: float
    subsume_during_vivification: bool
    subsumption_during_conflict_analysis: bool
    symmetry_detection_deterministic_time_limit: float
    symmetry_level: int
    table_compression_level: int
    transitive_precedences_work_limit: int
    use_absl_random: bool
    use_all_different_for_circuit: bool
    use_area_energetic_reasoning_in_no_overlap_2d: bool
    use_blocking_restart: bool
    use_chronological_backtracking: bool
    use_combined_no_overlap: bool
    use_conservative_scale_overload_checker: bool
    use_disjunctive_constraint_in_cumulative: bool
    use_dual_scheduling_heuristics: bool
    use_dynamic_precedence_in_cumulative: bool
    use_dynamic_precedence_in_disjunctive: bool
    use_energetic_reasoning_in_no_overlap_2d: bool
    use_erwa_heuristic: bool
    use_exact_lp_reason: bool
    use_extended_probing: bool
    use_feasibility_jump: bool
    use_feasibility_pump: bool
    use_hard_precedences_in_cumulative: bool
    use_implied_bounds: bool
    use_lb_relax_lns: bool
    use_linear3_for_no_overlap_2d_precedences: bool
    use_lns: bool
    use_lns_only: bool
    use_ls_only: bool
    use_new_integer_conflict_resolution: bool
    use_objective_lb_search: bool
    use_objective_shaving_search: bool
    use_optimization_hints: bool
    use_optional_variables: bool
    use_overload_checker_in_cumulative: bool
    use_pb_resolution: bool
    use_phase_saving: bool
    use_precedences_in_disjunctive_constraint: bool
    use_probing_search: bool
    use_rins_lns: bool
    use_sat_inprocessing: bool
    use_shared_tree_search: bool
    use_strong_propagation_in_disjunctive: bool
    use_symmetry_in_lp: bool
    use_timetable_edge_finding_in_cumulative: bool
    use_timetabling_in_no_overlap_2d: bool
    use_try_edge_reasoning_in_no_overlap_2d: bool
    variable_activity_decay: float
    variables_shaving_level: int
    violation_ls_compound_move_probability: float
    violation_ls_perturbation_period: int
    def __init__(self) -> None: ...
    def clear_absolute_gap_limit(self) -> None: ...
    def clear_add_cg_cuts(self) -> None: ...
    def clear_add_clique_cuts(self) -> None: ...
    def clear_add_lin_max_cuts(self) -> None: ...
    def clear_add_lp_constraints_lazily(self) -> None: ...
    def clear_add_mir_cuts(self) -> None: ...
    def clear_add_objective_cut(self) -> None: ...
    def clear_add_rlt_cuts(self) -> None: ...
    def clear_add_zero_half_cuts(self) -> None: ...
    def clear_also_bump_variables_in_conflict_reasons(self) -> None: ...
    def clear_alternative_pool_size(self) -> None: ...
    def clear_at_most_one_max_expansion_size(self) -> None: ...
    def clear_auto_detect_greater_than_at_least_one_of(self) -> None: ...
    def clear_binary_minimization_algorithm(self) -> None: ...
    def clear_binary_search_num_conflicts(self) -> None: ...
    def clear_blocking_restart_multiplier(self) -> None: ...
    def clear_blocking_restart_window_size(self) -> None: ...
    def clear_boolean_encoding_level(self) -> None: ...
    def clear_catch_sigint_signal(self) -> None: ...
    def clear_check_drat_proof(self) -> None: ...
    def clear_check_lrat_proof(self) -> None: ...
    def clear_check_merged_lrat_proof(self) -> None: ...
    def clear_chronological_backtrack_min_conflicts(self) -> None: ...
    def clear_clause_activity_decay(self) -> None: ...
    def clear_clause_cleanup_lbd_bound(self) -> None: ...
    def clear_clause_cleanup_lbd_tier1(self) -> None: ...
    def clear_clause_cleanup_lbd_tier2(self) -> None: ...
    def clear_clause_cleanup_ordering(self) -> None: ...
    def clear_clause_cleanup_period(self) -> None: ...
    def clear_clause_cleanup_period_increment(self) -> None: ...
    def clear_clause_cleanup_ratio(self) -> None: ...
    def clear_clause_cleanup_target(self) -> None: ...
    def clear_convert_intervals(self) -> None: ...
    def clear_core_minimization_level(self) -> None: ...
    def clear_count_assumption_levels_in_lbd(self) -> None: ...
    def clear_cover_optimization(self) -> None: ...
    def clear_cp_model_presolve(self) -> None: ...
    def clear_cp_model_probing_level(self) -> None: ...
    def clear_cp_model_use_sat_presolve(self) -> None: ...
    def clear_create_1uip_boolean_during_icr(self) -> None: ...
    def clear_cut_active_count_decay(self) -> None: ...
    def clear_cut_cleanup_target(self) -> None: ...
    def clear_cut_level(self) -> None: ...
    def clear_cut_max_active_count_value(self) -> None: ...
    def clear_debug_crash_if_lrat_check_fails(self) -> None: ...
    def clear_debug_crash_if_presolve_breaks_hint(self) -> None: ...
    def clear_debug_crash_on_bad_hint(self) -> None: ...
    def clear_debug_max_num_presolve_operations(self) -> None: ...
    def clear_debug_postsolve_with_full_solver(self) -> None: ...
    def clear_decision_subsumption_during_conflict_analysis(self) -> None: ...
    def clear_default_restart_algorithms(self) -> None: ...
    def clear_detect_linearized_product(self) -> None: ...
    def clear_detect_table_with_cost(self) -> None: ...
    def clear_disable_constraint_expansion(self) -> None: ...
    def clear_diversify_lns_params(self) -> None: ...
    def clear_eagerly_subsume_last_n_conflicts(self) -> None: ...
    def clear_encode_complex_linear_constraint_with_integer(self) -> None: ...
    def clear_encode_cumulative_as_reservoir(self) -> None: ...
    def clear_enumerate_all_solutions(self) -> None: ...
    def clear_expand_alldiff_constraints(self) -> None: ...
    def clear_expand_reservoir_constraints(self) -> None: ...
    def clear_expand_reservoir_using_circuit(self) -> None: ...
    def clear_exploit_all_lp_solution(self) -> None: ...
    def clear_exploit_all_precedences(self) -> None: ...
    def clear_exploit_best_solution(self) -> None: ...
    def clear_exploit_integer_lp_solution(self) -> None: ...
    def clear_exploit_objective(self) -> None: ...
    def clear_exploit_relaxation_solution(self) -> None: ...
    def clear_extra_subsumption_during_conflict_analysis(self) -> None: ...
    def clear_feasibility_jump_batch_dtime(self) -> None: ...
    def clear_feasibility_jump_decay(self) -> None: ...
    def clear_feasibility_jump_enable_restarts(self) -> None: ...
    def clear_feasibility_jump_linearization_level(self) -> None: ...
    def clear_feasibility_jump_max_expanded_constraint_size(self) -> None: ...
    def clear_feasibility_jump_restart_factor(self) -> None: ...
    def clear_feasibility_jump_var_perburbation_range_ratio(self) -> None: ...
    def clear_feasibility_jump_var_randomization_probability(self) -> None: ...
    def clear_fill_additional_solutions_in_response(self) -> None: ...
    def clear_fill_tightened_domains_in_response(self) -> None: ...
    def clear_filter_sat_postsolve_clauses(self) -> None: ...
    def clear_find_big_linear_overlap(self) -> None: ...
    def clear_find_clauses_that_are_exactly_one(self) -> None: ...
    def clear_find_multiple_cores(self) -> None: ...
    def clear_fix_variables_to_their_hinted_value(self) -> None: ...
    def clear_fp_rounding(self) -> None: ...
    def clear_glucose_decay_increment(self) -> None: ...
    def clear_glucose_decay_increment_period(self) -> None: ...
    def clear_glucose_max_decay(self) -> None: ...
    def clear_hint_conflict_limit(self) -> None: ...
    def clear_ignore_names(self) -> None: ...
    def clear_infer_all_diffs(self) -> None: ...
    def clear_initial_polarity(self) -> None: ...
    def clear_initial_variables_activity(self) -> None: ...
    def clear_inprocessing_dtime_ratio(self) -> None: ...
    def clear_inprocessing_minimization_dtime(self) -> None: ...
    def clear_inprocessing_minimization_use_all_orderings(self) -> None: ...
    def clear_inprocessing_minimization_use_conflict_analysis(self) -> None: ...
    def clear_inprocessing_probing_dtime(self) -> None: ...
    def clear_inprocessing_use_congruence_closure(self) -> None: ...
    def clear_inprocessing_use_sat_sweeping(self) -> None: ...
    def clear_instantiate_all_variables(self) -> None: ...
    def clear_interleave_batch_size(self) -> None: ...
    def clear_interleave_search(self) -> None: ...
    def clear_keep_all_feasible_solutions_in_presolve(self) -> None: ...
    def clear_keep_symmetry_in_presolve(self) -> None: ...
    def clear_lb_relax_num_workers_threshold(self) -> None: ...
    def clear_linear_split_size(self) -> None: ...
    def clear_linearization_level(self) -> None: ...
    def clear_lns_initial_deterministic_limit(self) -> None: ...
    def clear_lns_initial_difficulty(self) -> None: ...
    def clear_load_at_most_ones_in_sat_presolve(self) -> None: ...
    def clear_log_prefix(self) -> None: ...
    def clear_log_search_progress(self) -> None: ...
    def clear_log_subsolver_statistics(self) -> None: ...
    def clear_log_to_response(self) -> None: ...
    def clear_log_to_stdout(self) -> None: ...
    def clear_lp_dual_tolerance(self) -> None: ...
    def clear_lp_primal_tolerance(self) -> None: ...
    def clear_max_all_diff_cut_size(self) -> None: ...
    def clear_max_alldiff_domain_size(self) -> None: ...
    def clear_max_backjump_levels(self) -> None: ...
    def clear_max_clause_activity_value(self) -> None: ...
    def clear_max_consecutive_inactive_count(self) -> None: ...
    def clear_max_cut_rounds_at_level_zero(self) -> None: ...
    def clear_max_deterministic_time(self) -> None: ...
    def clear_max_domain_size_for_linear2_expansion(self) -> None: ...
    def clear_max_domain_size_when_encoding_eq_neq_constraints(self) -> None: ...
    def clear_max_drat_time_in_seconds(self) -> None: ...
    def clear_max_integer_rounding_scaling(self) -> None: ...
    def clear_max_lin_max_size_for_expansion(self) -> None: ...
    def clear_max_memory_in_mb(self) -> None: ...
    def clear_max_num_cuts(self) -> None: ...
    def clear_max_num_deterministic_batches(self) -> None: ...
    def clear_max_num_intervals_for_timetable_edge_finding(self) -> None: ...
    def clear_max_number_of_conflicts(self) -> None: ...
    def clear_max_pairs_pairwise_reasoning_in_no_overlap_2d(self) -> None: ...
    def clear_max_presolve_iterations(self) -> None: ...
    def clear_max_sat_assumption_order(self) -> None: ...
    def clear_max_sat_reverse_assumption_order(self) -> None: ...
    def clear_max_sat_stratification(self) -> None: ...
    def clear_max_size_to_create_precedence_literals_in_disjunctive(self) -> None: ...
    def clear_max_time_in_seconds(self) -> None: ...
    def clear_max_variable_activity_value(self) -> None: ...
    def clear_maximum_regions_to_split_in_disconnected_no_overlap_2d(self) -> None: ...
    def clear_merge_at_most_one_work_limit(self) -> None: ...
    def clear_merge_no_overlap_work_limit(self) -> None: ...
    def clear_min_orthogonality_for_lp_constraints(self) -> None: ...
    def clear_minimization_algorithm(self) -> None: ...
    def clear_minimize_reduction_during_pb_resolution(self) -> None: ...
    def clear_minimize_shared_clauses(self) -> None: ...
    def clear_mip_automatically_scale_variables(self) -> None: ...
    def clear_mip_check_precision(self) -> None: ...
    def clear_mip_compute_true_objective_bound(self) -> None: ...
    def clear_mip_drop_tolerance(self) -> None: ...
    def clear_mip_max_activity_exponent(self) -> None: ...
    def clear_mip_max_bound(self) -> None: ...
    def clear_mip_max_valid_magnitude(self) -> None: ...
    def clear_mip_presolve_level(self) -> None: ...
    def clear_mip_scale_large_domain(self) -> None: ...
    def clear_mip_treat_high_magnitude_bounds_as_infinity(self) -> None: ...
    def clear_mip_var_scaling(self) -> None: ...
    def clear_mip_wanted_precision(self) -> None: ...
    def clear_name(self) -> None: ...
    def clear_new_constraints_batch_size(self) -> None: ...
    def clear_new_linear_propagation(self) -> None: ...
    def clear_no_overlap_2d_boolean_relations_limit(self) -> None: ...
    def clear_num_conflicts_before_strategy_changes(self) -> None: ...
    def clear_num_full_subsolvers(self) -> None: ...
    def clear_num_search_workers(self) -> None: ...
    def clear_num_violation_ls(self) -> None: ...
    def clear_num_workers(self) -> None: ...
    def clear_only_add_cuts_at_level_zero(self) -> None: ...
    def clear_only_solve_ip(self) -> None: ...
    def clear_optimize_with_core(self) -> None: ...
    def clear_optimize_with_lb_tree_search(self) -> None: ...
    def clear_optimize_with_max_hs(self) -> None: ...
    def clear_output_drat_proof(self) -> None: ...
    def clear_output_lrat_proof(self) -> None: ...
    def clear_pb_cleanup_increment(self) -> None: ...
    def clear_pb_cleanup_ratio(self) -> None: ...
    def clear_permute_presolve_constraint_order(self) -> None: ...
    def clear_permute_variable_randomly(self) -> None: ...
    def clear_polarity_exploit_ls_hints(self) -> None: ...
    def clear_polarity_rephase_increment(self) -> None: ...
    def clear_polish_lp_solution(self) -> None: ...
    def clear_preferred_variable_order(self) -> None: ...
    def clear_presolve_blocked_clause(self) -> None: ...
    def clear_presolve_bva_threshold(self) -> None: ...
    def clear_presolve_bve_clause_weight(self) -> None: ...
    def clear_presolve_bve_threshold(self) -> None: ...
    def clear_presolve_extract_integer_enforcement(self) -> None: ...
    def clear_presolve_inclusion_work_limit(self) -> None: ...
    def clear_presolve_probing_deterministic_time_limit(self) -> None: ...
    def clear_presolve_substitution_level(self) -> None: ...
    def clear_presolve_use_bva(self) -> None: ...
    def clear_probing_deterministic_time_limit(self) -> None: ...
    def clear_probing_num_combinations_limit(self) -> None: ...
    def clear_propagation_loop_detection_factor(self) -> None: ...
    def clear_pseudo_cost_reliability_threshold(self) -> None: ...
    def clear_push_all_tasks_toward_start(self) -> None: ...
    def clear_random_branches_ratio(self) -> None: ...
    def clear_random_polarity_ratio(self) -> None: ...
    def clear_random_seed(self) -> None: ...
    def clear_randomize_search(self) -> None: ...
    def clear_relative_gap_limit(self) -> None: ...
    def clear_remove_fixed_variables_early(self) -> None: ...
    def clear_repair_hint(self) -> None: ...
    def clear_restart_dl_average_ratio(self) -> None: ...
    def clear_restart_lbd_average_ratio(self) -> None: ...
    def clear_restart_period(self) -> None: ...
    def clear_restart_running_window_size(self) -> None: ...
    def clear_root_lp_iterations(self) -> None: ...
    def clear_routing_cut_dp_effort(self) -> None: ...
    def clear_routing_cut_max_infeasible_path_length(self) -> None: ...
    def clear_routing_cut_subset_size_for_binary_relation_bound(self) -> None: ...
    def clear_routing_cut_subset_size_for_exact_binary_relation_bound(self) -> None: ...
    def clear_routing_cut_subset_size_for_shortest_paths_bound(self) -> None: ...
    def clear_routing_cut_subset_size_for_tight_binary_relation_bound(self) -> None: ...
    def clear_save_lp_basis_in_lb_tree_search(self) -> None: ...
    def clear_search_branching(self) -> None: ...
    def clear_search_random_variable_pool_size(self) -> None: ...
    def clear_share_binary_clauses(self) -> None: ...
    def clear_share_glue_clauses(self) -> None: ...
    def clear_share_glue_clauses_dtime(self) -> None: ...
    def clear_share_level_zero_bounds(self) -> None: ...
    def clear_share_linear2_bounds(self) -> None: ...
    def clear_share_objective_bounds(self) -> None: ...
    def clear_shared_tree_balance_tolerance(self) -> None: ...
    def clear_shared_tree_max_nodes_per_worker(self) -> None: ...
    def clear_shared_tree_num_workers(self) -> None: ...
    def clear_shared_tree_open_leaves_per_worker(self) -> None: ...
    def clear_shared_tree_split_min_dtime(self) -> None: ...
    def clear_shared_tree_split_strategy(self) -> None: ...
    def clear_shared_tree_worker_enable_phase_sharing(self) -> None: ...
    def clear_shared_tree_worker_enable_trail_sharing(self) -> None: ...
    def clear_shared_tree_worker_min_restarts_per_subtree(self) -> None: ...
    def clear_shaving_deterministic_time_in_probing_search(self) -> None: ...
    def clear_shaving_search_deterministic_time(self) -> None: ...
    def clear_shaving_search_threshold(self) -> None: ...
    def clear_solution_pool_diversity_limit(self) -> None: ...
    def clear_solution_pool_size(self) -> None: ...
    def clear_stop_after_first_solution(self) -> None: ...
    def clear_stop_after_presolve(self) -> None: ...
    def clear_stop_after_root_propagation(self) -> None: ...
    def clear_strategy_change_increase_ratio(self) -> None: ...
    def clear_subsume_during_vivification(self) -> None: ...
    def clear_subsumption_during_conflict_analysis(self) -> None: ...
    def clear_symmetry_detection_deterministic_time_limit(self) -> None: ...
    def clear_symmetry_level(self) -> None: ...
    def clear_table_compression_level(self) -> None: ...
    def clear_transitive_precedences_work_limit(self) -> None: ...
    def clear_use_absl_random(self) -> None: ...
    def clear_use_all_different_for_circuit(self) -> None: ...
    def clear_use_area_energetic_reasoning_in_no_overlap_2d(self) -> None: ...
    def clear_use_blocking_restart(self) -> None: ...
    def clear_use_chronological_backtracking(self) -> None: ...
    def clear_use_combined_no_overlap(self) -> None: ...
    def clear_use_conservative_scale_overload_checker(self) -> None: ...
    def clear_use_disjunctive_constraint_in_cumulative(self) -> None: ...
    def clear_use_dual_scheduling_heuristics(self) -> None: ...
    def clear_use_dynamic_precedence_in_cumulative(self) -> None: ...
    def clear_use_dynamic_precedence_in_disjunctive(self) -> None: ...
    def clear_use_energetic_reasoning_in_no_overlap_2d(self) -> None: ...
    def clear_use_erwa_heuristic(self) -> None: ...
    def clear_use_exact_lp_reason(self) -> None: ...
    def clear_use_extended_probing(self) -> None: ...
    def clear_use_feasibility_jump(self) -> None: ...
    def clear_use_feasibility_pump(self) -> None: ...
    def clear_use_hard_precedences_in_cumulative(self) -> None: ...
    def clear_use_implied_bounds(self) -> None: ...
    def clear_use_lb_relax_lns(self) -> None: ...
    def clear_use_linear3_for_no_overlap_2d_precedences(self) -> None: ...
    def clear_use_lns(self) -> None: ...
    def clear_use_lns_only(self) -> None: ...
    def clear_use_ls_only(self) -> None: ...
    def clear_use_new_integer_conflict_resolution(self) -> None: ...
    def clear_use_objective_lb_search(self) -> None: ...
    def clear_use_objective_shaving_search(self) -> None: ...
    def clear_use_optimization_hints(self) -> None: ...
    def clear_use_optional_variables(self) -> None: ...
    def clear_use_overload_checker_in_cumulative(self) -> None: ...
    def clear_use_pb_resolution(self) -> None: ...
    def clear_use_phase_saving(self) -> None: ...
    def clear_use_precedences_in_disjunctive_constraint(self) -> None: ...
    def clear_use_probing_search(self) -> None: ...
    def clear_use_rins_lns(self) -> None: ...
    def clear_use_sat_inprocessing(self) -> None: ...
    def clear_use_shared_tree_search(self) -> None: ...
    def clear_use_strong_propagation_in_disjunctive(self) -> None: ...
    def clear_use_symmetry_in_lp(self) -> None: ...
    def clear_use_timetable_edge_finding_in_cumulative(self) -> None: ...
    def clear_use_timetabling_in_no_overlap_2d(self) -> None: ...
    def clear_use_try_edge_reasoning_in_no_overlap_2d(self) -> None: ...
    def clear_variable_activity_decay(self) -> None: ...
    def clear_variables_shaving_level(self) -> None: ...
    def clear_violation_ls_compound_move_probability(self) -> None: ...
    def clear_violation_ls_perturbation_period(self) -> None: ...
    def copy_from(self, arg0: SatParameters) -> None: ...
    def merge_from(self, arg0: SatParameters) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> SatParameters: ...
    def __deepcopy__(self, arg0: dict) -> SatParameters: ...
    @property
    def extra_subsolvers(self): ...
    @property
    def filter_subsolvers(self): ...
    @property
    def ignore_subsolvers(self): ...
    @property
    def restart_algorithms(self): ...
    @property
    def subsolver_params(self): ...
    @property
    def subsolvers(self): ...

class SolutionCallback:
    def __init__(self) -> None: ...
    def BestObjectiveBound(self) -> float: ...
    @overload
    def BooleanValue(self, arg0) -> bool: ...
    @overload
    def BooleanValue(self, arg0: bool) -> bool: ...
    def DeterministicTime(self) -> float: ...
    @overload
    def FloatValue(self, arg0) -> float: ...
    @overload
    def FloatValue(self, arg0: float) -> float: ...
    def HasResponse(self) -> bool: ...
    def NumBinaryPropagations(self) -> int: ...
    def NumBooleans(self) -> int: ...
    def NumBranches(self) -> int: ...
    def NumConflicts(self) -> int: ...
    def NumIntegerPropagations(self) -> int: ...
    def ObjectiveValue(self) -> float: ...
    def OnSolutionCallback(self) -> None: ...
    def Response(self, *args, **kwargs): ...
    def SolutionBooleanValue(self, index: int) -> bool: ...
    def SolutionIntegerValue(self, index: int) -> int: ...
    def StopSearch(self) -> None: ...
    def UserTime(self) -> float: ...
    @overload
    def Value(self, arg0) -> int: ...
    @overload
    def Value(self, arg0: int) -> int: ...
    def WallTime(self) -> float: ...

class SolveWrapper:
    def __init__(self) -> None: ...
    def add_best_bound_callback(self, best_bound_callback: Callable[[float], None]) -> None: ...
    def add_log_callback(self, log_callback: Callable[[str], None]) -> None: ...
    def add_solution_callback(self, callback: SolutionCallback) -> None: ...
    def clear_solution_callback(self, arg0: SolutionCallback) -> None: ...
    def set_parameters(self, parameters) -> None: ...
    def solve(self, *args, **kwargs): ...
    def stop_search(self) -> None: ...

class SparsePermutationProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: SparsePermutationProto) -> None: ...
    def merge_from(self, arg0: SparsePermutationProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> SparsePermutationProto: ...
    def __deepcopy__(self, arg0: dict) -> SparsePermutationProto: ...
    @property
    def cycle_sizes(self): ...
    @property
    def support(self): ...

class SumArray(LinearExpr):
    def __init__(self, arg0: list[LinearExpr], arg1: int, arg2: float) -> None: ...
    @overload
    def __add__(self, other: LinearExpr) -> LinearExpr: ...
    @overload
    def __add__(self, arg0: int) -> LinearExpr: ...
    @overload
    def __add__(self, other: float) -> LinearExpr: ...
    @overload
    def __iadd__(self, other: LinearExpr) -> LinearExpr: ...
    @overload
    def __iadd__(self, arg0: int) -> LinearExpr: ...
    @overload
    def __iadd__(self, other: float) -> LinearExpr: ...
    @overload
    def __isub__(self, other: LinearExpr) -> LinearExpr: ...
    @overload
    def __isub__(self, arg0: int) -> LinearExpr: ...
    @overload
    def __isub__(self, other: float) -> LinearExpr: ...
    @overload
    def __radd__(self, other: LinearExpr) -> LinearExpr: ...
    @overload
    def __radd__(self, cst: int) -> LinearExpr: ...
    @overload
    def __radd__(self, cst: float) -> LinearExpr: ...
    @overload
    def __sub__(self, other: LinearExpr) -> LinearExpr: ...
    @overload
    def __sub__(self, cst: int) -> LinearExpr: ...
    @overload
    def __sub__(self, cst: float) -> LinearExpr: ...
    @property
    def double_offset(self) -> float: ...
    @property
    def int_offset(self) -> int: ...
    @property
    def num_exprs(self) -> int: ...

class SymmetryProto:
    def __init__(self) -> None: ...
    def copy_from(self, arg0: SymmetryProto) -> None: ...
    def merge_from(self, arg0: SymmetryProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> SymmetryProto: ...
    def __deepcopy__(self, arg0: dict) -> SymmetryProto: ...
    @property
    def orbitopes(self): ...
    @property
    def permutations(self): ...

class TableConstraintProto:
    negated: bool
    def __init__(self) -> None: ...
    def clear_negated(self) -> None: ...
    def copy_from(self, arg0: TableConstraintProto) -> None: ...
    def merge_from(self, arg0: TableConstraintProto) -> None: ...
    def merge_text_format(self, arg0: str) -> bool: ...
    def parse_text_format(self, arg0: str) -> bool: ...
    def __copy__(self) -> TableConstraintProto: ...
    def __deepcopy__(self, arg0: dict) -> TableConstraintProto: ...
    @property
    def exprs(self): ...
    @property
    def values(self): ...
    @property
    def vars(self): ...

class repeated_ConstraintProto:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> ConstraintProto: ...
    def append(self, arg0: ConstraintProto) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[ConstraintProto]) -> None: ...
    def __getitem__(self, arg0: int) -> ConstraintProto: ...
    def __iter__(self) -> typing.Iterator[ConstraintProto]: ...
    def __len__(self) -> int: ...

class repeated_CpSolverSolution:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> CpSolverSolution: ...
    def append(self, arg0: CpSolverSolution) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[CpSolverSolution]) -> None: ...
    def __getitem__(self, arg0: int) -> CpSolverSolution: ...
    def __iter__(self) -> typing.Iterator[CpSolverSolution]: ...
    def __len__(self) -> int: ...

class repeated_DecisionStrategyProto:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> DecisionStrategyProto: ...
    def append(self, arg0: DecisionStrategyProto) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[DecisionStrategyProto]) -> None: ...
    def __getitem__(self, arg0: int) -> DecisionStrategyProto: ...
    def __iter__(self) -> typing.Iterator[DecisionStrategyProto]: ...
    def __len__(self) -> int: ...

class repeated_DenseMatrixProto:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> DenseMatrixProto: ...
    def append(self, arg0: DenseMatrixProto) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[DenseMatrixProto]) -> None: ...
    def __getitem__(self, arg0: int) -> DenseMatrixProto: ...
    def __iter__(self) -> typing.Iterator[DenseMatrixProto]: ...
    def __len__(self) -> int: ...

class repeated_IntegerVariableProto:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> IntegerVariableProto: ...
    def append(self, arg0: IntegerVariableProto) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[IntegerVariableProto]) -> None: ...
    def __getitem__(self, arg0: int) -> IntegerVariableProto: ...
    def __iter__(self) -> typing.Iterator[IntegerVariableProto]: ...
    def __len__(self) -> int: ...

class repeated_LinearExpressionProto:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> LinearExpressionProto: ...
    def append(self, arg0: LinearExpressionProto) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[LinearExpressionProto]) -> None: ...
    def __getitem__(self, arg0: int) -> LinearExpressionProto: ...
    def __iter__(self) -> typing.Iterator[LinearExpressionProto]: ...
    def __len__(self) -> int: ...

class repeated_NodeExpressions:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> RoutesConstraintProto.NodeExpressions: ...
    def append(self, arg0: RoutesConstraintProto.NodeExpressions) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[RoutesConstraintProto.NodeExpressions]) -> None: ...
    def __getitem__(self, arg0: int) -> RoutesConstraintProto.NodeExpressions: ...
    def __iter__(self) -> typing.Iterator[RoutesConstraintProto.NodeExpressions]: ...
    def __len__(self) -> int: ...

class repeated_SatParameters:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> SatParameters: ...
    def append(self, arg0: SatParameters) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[SatParameters]) -> None: ...
    def __getitem__(self, arg0: int) -> SatParameters: ...
    def __iter__(self) -> typing.Iterator[SatParameters]: ...
    def __len__(self) -> int: ...

class repeated_SparsePermutationProto:
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self) -> SparsePermutationProto: ...
    def append(self, arg0: SparsePermutationProto) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[SparsePermutationProto]) -> None: ...
    def __getitem__(self, arg0: int) -> SparsePermutationProto: ...
    def __iter__(self) -> typing.Iterator[SparsePermutationProto]: ...
    def __len__(self) -> int: ...

class repeated_scalar_double:
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, arg0: float) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[float]) -> None: ...
    def __getitem__(self, arg0: int) -> float: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: float) -> None: ...

class repeated_scalar_int32_t:
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, arg0: int) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[int]) -> None: ...
    def __getitem__(self, arg0: int) -> int: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: int) -> None: ...

class repeated_scalar_int64_t:
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, arg0: int) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[int]) -> None: ...
    def __getitem__(self, arg0: int) -> int: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: int) -> None: ...

class repeated_scalar_operations_research_sat_SatParameters_RestartAlgorithm:
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, arg0) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0) -> None: ...
    def __getitem__(self, index): ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1) -> None: ...

class repeated_scalar_std_string:
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, arg0: str) -> None: ...
    def clear(self) -> None: ...
    def extend(self, arg0: list[str]) -> None: ...
    def __getitem__(self, arg0: int) -> str: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: str) -> None: ...

def rebuild_from_linear_expression_proto(proto, model_proto) -> object: ...
